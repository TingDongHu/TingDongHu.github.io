<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>继承 on 古月月仔的博客</title>
    <link>http://localhost:1313/tags/%E7%BB%A7%E6%89%BF/</link>
    <description>Recent content in 继承 on 古月月仔的博客</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 05 Jan 2026 00:00:00 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/%E7%BB%A7%E6%89%BF/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【C&#43;&#43;】组合、继承和多态</title>
      <link>http://localhost:1313/posts/c&#43;&#43;%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/</link>
      <pubDate>Mon, 05 Jan 2026 00:00:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/c&#43;&#43;%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/</guid>
      <description>&lt;p&gt;组合（Composition）、继承（Inheritance）和多态（Polymorphism）是C++中面向对象编程（OOP）的三大支柱。&lt;/p&gt;&#xA;&lt;p&gt;之前只在大学课本上学到一点皮毛，在此做复习和深入挖掘。&lt;/p&gt;&#xA;&lt;h2 id=&#34;组合-composition物理嵌套与高效复用&#34;&gt;组合 (Composition)物理嵌套与高效复用&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;组合&lt;/strong&gt;描述的是一种“有一个 (Has-a)”的关系。在 C++ 中，当我们将一个类的对象作为另一个类的数据成员时，就形成了组合。&lt;/p&gt;&#xA;&lt;p&gt;从内存布局的角度来看，组合体现为&lt;strong&gt;物理上的直接嵌套&lt;/strong&gt;：成员对象的所有数据成员被完整地包含在宿主对象的内存空间内。这意味着，如果你在栈上创建一个宿主对象，其组合的所有成员也都在栈上；同理，若宿主在堆上，成员也在堆上。&lt;/p&gt;&#xA;&lt;p&gt;这种布局方式带来了极高的执行效率，因为数据在内存中是连续存放的，极大提高了 CPU 的缓存命中率。&lt;/p&gt;&#xA;&lt;p&gt;在初始化逻辑上，C++ 遵循严格的顺序：&lt;strong&gt;成员对象先构造，宿主对象后构造&lt;/strong&gt;；析构时则完全相反。设计上，C++ 社区推崇“优先使用组合而非继承”，因为组合是一种“黑盒复用”，宿主类只需关心成员类的公共接口，而不需要了解其内部实现，这大大降低了代码间的耦合度。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Engine&lt;/span&gt; { &lt;span style=&#34;color:#75715e&#34;&gt;/* 引擎数据 */&lt;/span&gt; };&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Car&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Engine engine; &lt;span style=&#34;color:#75715e&#34;&gt;// Car 组合了 Engine&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果你在栈上创建一个 &lt;code&gt;Car&lt;/code&gt; 对象，那么 &lt;code&gt;Engine&lt;/code&gt; 的数据会&lt;strong&gt;直接包含&lt;/strong&gt;在 &lt;code&gt;Car&lt;/code&gt; 的内存块内部。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;设计原则&lt;/strong&gt;：&lt;strong&gt;优先使用组合，而不是继承&lt;/strong&gt;。组合耦合度低，灵活性高。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;生命周期&lt;/strong&gt;：成员对象（Engine）随宿主对象（Car）的创建而创建，随其销毁而销毁。&lt;/p&gt;&#xA;&lt;h2 id=&#34;继承-inheritance结构延伸与逻辑分类&#34;&gt;继承 (Inheritance)：结构延伸与逻辑分类&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;继承&lt;/strong&gt;建立的是一种“是一个 (Is-a)”的关系，允许你基于已有的类创建新类，从而复用代码。它允许子类继承父类的属性和行为。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Animal&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; age;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;eat&lt;/span&gt;() { std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Eating...&amp;#34;&lt;/span&gt;; }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Cat&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Animal { &lt;span style=&#34;color:#75715e&#34;&gt;// Cat 继承自 Animal&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; meow() { std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Meow!&amp;#34;&lt;/span&gt;; }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;派生类（Cat）的内存结构是：&lt;strong&gt;父类的数据成员 + 派生类特有的数据成员&lt;/strong&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>【虚幻引擎】GameMode和GameSate</title>
      <link>http://localhost:1313/posts/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8Egamemode%E5%92%8Cgamesate/</link>
      <pubDate>Sun, 21 Apr 2024 00:00:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8Egamemode%E5%92%8Cgamesate/</guid>
      <description>&lt;p&gt;GameMode是服务器端权威的游戏规则管理者，定义核心逻辑；GameState则负责在服务器与客户端间同步全局游戏状态，如比分和时间。&lt;/p&gt;&#xA;&lt;p&gt;&lt;figure style=&#34;text-align: center; margin: 1.5rem auto;&#34;&gt;&#xA;  &#xA;  &lt;img src=&#34;http://localhost:1313/posts/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8Egamemode%E5%92%8Cgamesate/image-20250422211945454.png&#34; &#xA;       alt=&#34;image-20250422211945454&#34; &#xA;       &#xA;       class=&#34;zoomable&#34; &#xA;       style=&#34;max-width: 100%; height: auto; border-radius: 8px; cursor: zoom-in;&#34;&#xA;       loading=&#34;lazy&#34; /&gt;&#xA;  &#xA;    &lt;figcaption style=&#34;margin-top: 8px; font-size: 0.85em; color: #888; font-style: italic;&#34;&gt;&#xA;      image-20250422211945454&#xA;    &lt;/figcaption&gt;&#xA;  &#xA;&lt;/figure&gt;&lt;/p&gt;&#xA;&lt;p&gt;在虚幻引擎（Unreal Engine）中，&lt;strong&gt;GameMode&lt;/strong&gt; 和 &lt;strong&gt;GameState&lt;/strong&gt; 都是多人游戏中的核心类，但它们的分工和用途有显著区别。以下是它们的对比和典型应用场景：&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;1-gamemode游戏规则管理者&#34;&gt;&lt;strong&gt;1. GameMode（游戏规则管理者）&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;h4 id=&#34;职责&#34;&gt;&lt;strong&gt;职责&lt;/strong&gt;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;仅存在于服务器端&lt;/strong&gt;（不会复制到客户端）。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;定义游戏的核心规则&lt;/strong&gt;：胜利条件、玩家生成逻辑、回合制规则等。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;管理玩家登录/退出&lt;/strong&gt;（通过&lt;code&gt;Login&lt;/code&gt;/&lt;code&gt;Logout&lt;/code&gt;等事件）。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;生成并持有PlayerController、PlayerState等&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;典型用途&#34;&gt;&lt;strong&gt;典型用途&lt;/strong&gt;&lt;/h4&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 示例：在GameMode中设置玩家生成逻辑&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; AMyGameMode&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;PostLogin(APlayerController&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; NewPlayer) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Super&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;PostLogin(NewPlayer);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 生成玩家角色&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (NewPlayer&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;GetPawn() &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nullptr&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        SpawnPlayerAtTransform(NewPlayer, SpawnTransform);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;关键特性&#34;&gt;&lt;strong&gt;关键特性&lt;/strong&gt;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;服务器权威&lt;/strong&gt;：客户端无法修改GameMode的逻辑。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;不复制&lt;/strong&gt;：客户端无法直接访问GameMode。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;2-gamestate游戏状态同步者&#34;&gt;&lt;strong&gt;2. GameState（游戏状态同步者）&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;h4 id=&#34;职责-1&#34;&gt;&lt;strong&gt;职责&lt;/strong&gt;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;存在于服务器和客户端&lt;/strong&gt;（自动复制到所有客户端）。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;存储并同步游戏全局状态&lt;/strong&gt;：比分、剩余时间、玩家列表等。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;提供客户端可见的数据&lt;/strong&gt;（如通过&lt;code&gt;PlayerArray&lt;/code&gt;访问所有玩家的&lt;code&gt;PlayerState&lt;/code&gt;）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;典型用途-1&#34;&gt;&lt;strong&gt;典型用途&lt;/strong&gt;&lt;/h4&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 示例：在GameState中同步比分&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; AMyGameState&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;OnRep_TeamScores() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 客户端更新UI显示比分&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    UpdateScoreboardUI(TeamAScore, TeamBScore);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;关键特性-1&#34;&gt;&lt;strong&gt;关键特性&lt;/strong&gt;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;数据同步&lt;/strong&gt;：通过属性复制（&lt;code&gt;Replicated&lt;/code&gt;）或RPC同步到客户端。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;客户端可读&lt;/strong&gt;：UI可以直接绑定GameState的数据（如剩余时间）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;核心区别对比&#34;&gt;&lt;strong&gt;核心区别对比&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;&lt;strong&gt;特性&lt;/strong&gt;&lt;/th&gt;&#xA;          &lt;th&gt;&lt;strong&gt;GameMode&lt;/strong&gt;&lt;/th&gt;&#xA;          &lt;th&gt;&lt;strong&gt;GameState&lt;/strong&gt;&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;存在位置&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;仅服务器&lt;/td&gt;&#xA;          &lt;td&gt;服务器 + 客户端（复制）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;用途&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;定义规则、逻辑控制&lt;/td&gt;&#xA;          &lt;td&gt;存储和同步全局状态&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;是否复制到客户端&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;❌ 否&lt;/td&gt;&#xA;          &lt;td&gt;✅ 是&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;客户端访问权限&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;无法直接访问&lt;/td&gt;&#xA;          &lt;td&gt;可读取数据（如显示比分）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;生命周期&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;游戏开始时创建，结束时销毁&lt;/td&gt;&#xA;          &lt;td&gt;随游戏运行持续存在&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;协作流程示例&#34;&gt;&lt;strong&gt;协作流程示例&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;服务器&lt;/strong&gt;：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;GameMode决定玩家生成规则（如出生点选择）。&lt;/li&gt;&#xA;&lt;li&gt;GameState更新并同步比分到所有客户端。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;客户端&lt;/strong&gt;：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过GameState获取实时比分，更新UI。&lt;/li&gt;&#xA;&lt;li&gt;无法修改规则（必须通过服务器GameMode）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;何时使用&#34;&gt;&lt;strong&gt;何时使用？&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;用GameMode&lt;/strong&gt;：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;需要权威控制游戏逻辑（如判断胜利条件）。&lt;/li&gt;&#xA;&lt;li&gt;处理玩家登录/退出等敏感操作。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;用GameState&lt;/strong&gt;：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;需要让所有客户端知道全局状态（如倒计时、玩家列表）。&lt;/li&gt;&#xA;&lt;li&gt;UI需要绑定的动态数据（如实时比分）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;通过这种分工，虚幻引擎实现了&lt;strong&gt;逻辑与状态的分离&lt;/strong&gt;，确保多人游戏的同步性和安全性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>【虚幻引擎】虚幻5.1UUserWidget不再包含OnLevelRemovedFromWorld的问题</title>
      <link>http://localhost:1313/posts/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E8%99%9A%E5%B9%BB5.1uuserwidget%E4%B8%8D%E5%86%8D%E5%8C%85%E5%90%ABonlevelremovedfromworld%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 20 Apr 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E8%99%9A%E5%B9%BB5.1uuserwidget%E4%B8%8D%E5%86%8D%E5%8C%85%E5%90%ABonlevelremovedfromworld%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;p&gt;在虚幻引擎5.1中，&lt;code&gt;OnLevelRemovedFromWorld&lt;/code&gt;函数已被移除，导致编译错误。解决方案是重写&lt;code&gt;NativeDestruct&lt;/code&gt;函数来实现相同的资源清理逻辑，从而成功编译。&lt;/p&gt;&#xA;&lt;p&gt;在跟着Blaster课程项目写Menu插件的时候,在Menu.h中一直报以下错误无法编译,百思不得其解.&lt;/p&gt;&#xA;&lt;p&gt;&lt;figure style=&#34;text-align: center; margin: 1.5rem auto;&#34;&gt;&#xA;  &#xA;  &lt;img src=&#34;http://localhost:1313/posts/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E8%99%9A%E5%B9%BB5.1uuserwidget%E4%B8%8D%E5%86%8D%E5%8C%85%E5%90%ABonlevelremovedfromworld%E7%9A%84%E9%97%AE%E9%A2%98/image-20250421115907081.png&#34; &#xA;       alt=&#34;image-20250421115907081&#34; &#xA;       &#xA;       class=&#34;zoomable&#34; &#xA;       style=&#34;max-width: 100%; height: auto; border-radius: 8px; cursor: zoom-in;&#34;&#xA;       loading=&#34;lazy&#34; /&gt;&#xA;  &#xA;    &lt;figcaption style=&#34;margin-top: 8px; font-size: 0.85em; color: #888; font-style: italic;&#34;&gt;&#xA;      image-20250421115907081&#xA;    &lt;/figcaption&gt;&#xA;  &#xA;&lt;/figure&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &lt;blockquote&gt;&#xA;    &lt;p&gt;严重性代码说明项目文件33行禁止显示状态详细信息&#xA;错误C3668“UMenu::OnLevelRemovedFromWorld”: 包含重写说明符“override”的方法没有重写任何基类方法MenuSystem&#x9;F:\UE\UEproject\MultiplayCourse\MenuSystem\Plugins\MultiplayerSessions\Source\MultiplayerSessions\Public\Menu.h23&lt;/p&gt;&#xA;&#xA;  &lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;figure style=&#34;text-align: center; margin: 1.5rem auto;&#34;&gt;&#xA;  &#xA;  &lt;img src=&#34;http://localhost:1313/posts/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E8%99%9A%E5%B9%BB5.1uuserwidget%E4%B8%8D%E5%86%8D%E5%8C%85%E5%90%ABonlevelremovedfromworld%E7%9A%84%E9%97%AE%E9%A2%98/image-20250421120505541.png&#34; &#xA;       alt=&#34;image-20250421120505541&#34; &#xA;       &#xA;       class=&#34;zoomable&#34; &#xA;       style=&#34;max-width: 100%; height: auto; border-radius: 8px; cursor: zoom-in;&#34;&#xA;       loading=&#34;lazy&#34; /&gt;&#xA;  &#xA;    &lt;figcaption style=&#34;margin-top: 8px; font-size: 0.85em; color: #888; font-style: italic;&#34;&gt;&#xA;      image-20250421120505541&#xA;    &lt;/figcaption&gt;&#xA;  &#xA;&lt;/figure&gt;&lt;/p&gt;&#xA;&lt;p&gt;查阅资料后发现是虚幻5.1和5.0的版本问题: 虚幻5.1 UUserWidget不再包含OnLevelRemovedFromWorld.我们可以重载一个类似的函数用于达到相同的效果:&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;NativeDestruct&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;override&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;.cpp&lt;/code&gt;文件中实现:&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; UMenu&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;NativeDestruct()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    MenuTearDown();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Super&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;NativeDestruct();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;NativeDestruct()&lt;/code&gt; 是 &lt;code&gt;UUserWidget&lt;/code&gt;（用户控件）提供的一个 &lt;strong&gt;关键生命周期虚函数&lt;/strong&gt;(析构函数)，用于 &lt;strong&gt;处理控件的销毁逻辑&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;调用时机&lt;/strong&gt;：&#xA;当 &lt;code&gt;UUserWidget&lt;/code&gt; 被 ​&lt;strong&gt;显式移除（&lt;code&gt;RemoveFromParent&lt;/code&gt;）​&lt;/strong&gt;​ 或 ​&lt;strong&gt;其所属的 &lt;code&gt;UWorld&lt;/code&gt; 销毁时&lt;/strong&gt;​（如关卡切换、游戏退出），引擎会自动调用此函数。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;类比&lt;/strong&gt;：类似于 Actor 的 &lt;code&gt;EndPlay()&lt;/code&gt; 或 C++ 对象的析构函数。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;核心用途&lt;/strong&gt;：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;释放资源&lt;/strong&gt;：清理绑定的动态委托（如按钮点击事件）、断开外部引用、销毁子控件等。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;防止内存泄漏&lt;/strong&gt;：确保所有手动绑定的回调（如 &lt;code&gt;UWorld&lt;/code&gt; 事件）被正确解绑。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;替换后可正常编译与生成项目,问题解决.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
