<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on 古月月仔的博客</title>
    <link>http://localhost:1313/categories/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on 古月月仔的博客</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 01 Jan 2026 00:00:00 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【C&#43;&#43;】LearnCppDate</title>
      <link>http://localhost:1313/posts/c&#43;&#43;learncppdate/</link>
      <pubDate>Thu, 01 Jan 2026 00:00:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/c&#43;&#43;learncppdate/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;最近在学习的时候发现自己陷入了一个瓶颈，就是发现自己过去主要的学习方式&amp;ndash;看视频，大脑有点脱敏，且频频走神。看视频时常产生一种“我在进步”的错觉，但实际写代码时会大脑一片空白。&lt;/p&gt;&#xA;&lt;p&gt;之前看过的一本书&lt;a href=&#34;https://1000h.org/training-tasks/language.html&#34; target=&#34;_blank&#34;&gt;《1000hours》&lt;/a&gt;&#xA;里曾经提到一种理论，和我现在的情况很像，就是如果在学习一项技能，或者学习一个新事物时，如果仅仅是投入时间和金钱，但是没有投入最重要的&lt;strong&gt;注意力&lt;/strong&gt;，则其效率会变的非常低下。&lt;/p&gt;&#xA;&lt;p&gt;自己思考了一下发现自己现在日常生活中最专注的情况主要是：读书、和AI深度交流、完全沉浸式的娱乐；基于自己的专注能力，打算亲身实践一下新的学习方法，即啃高信息密度的书/文档、遇到不懂的问题问AI，遇到需要动图辅助理解的知识点再去找视频讲解，最后对每日啃过的内容进行一个思维整理输出，写为笔记方便复习，希望新的学习方法能改善我当前的学习困境。&lt;/p&gt;&#xA;&lt;p&gt;本篇笔记的内容也主要集中于我在啃这个网站&lt;a href=&#34;https://www.learncpp.com/&#34; target=&#34;_blank&#34;&gt;Learn C++ – Skill up with our free tutorials&lt;/a&gt;&#xA;文档内容的每日总结输出，和中间过程与AI探讨的一些小Tips和理解。&lt;/p&gt;&#xA;&lt;h2 id=&#34;day01&#34;&gt;Day01&lt;/h2&gt;&#xA;&lt;h3 id=&#34;programs-and-programming-languages&#34;&gt;Programs and programming languages&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;计算机硬件的局限性与“二进制”语言&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;计算机的核心由 &lt;strong&gt;CPU（中央处理器）&lt;/strong&gt; 和 &lt;strong&gt;内存（RAM）&lt;/strong&gt; 组成。尽管 CPU 拥有强大的计算能力，但它本质上是非常“笨”的，只能识别电信号的通（1）与断（0）。这意味着，计算机原生唯一能理解的语言就是&lt;strong&gt;机器语言（Machine Language）&lt;/strong&gt;。程序员在早期必须通过冗长的 0 和 1 序列来下达指令，这不仅极其违反人类直觉、容易出错，而且由于不同厂家的 CPU 指令集各异，一份代码无法在不同的电脑上通用，这种“不可移植性”严重限制了软件的发展。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;低级语言的改良：汇编语言的过渡&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;为了缓解机器语言带来的痛苦，&lt;strong&gt;汇编语言（Assembly Language）&lt;/strong&gt; 应运而生。它引入了“助记符”的概念，用简单的英文单词（如 &lt;code&gt;ADD&lt;/code&gt;、&lt;code&gt;MOV&lt;/code&gt;）代替了晦涩的二进制码。虽然这让代码变得稍微可读了一些，但它依然属于&lt;strong&gt;低级语言&lt;/strong&gt;。汇编语言与底层硬件是一一对应的，程序员仍需关注寄存器和内存地址等硬件细节。此外，它依然需要一个名为“汇编器”的工具将其翻译回机器码，且跨平台运行的问题依然没有得到根本解决。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;高级语言的革命：效率与跨平台的飞跃&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;为了让编程真正回归逻辑本身，&lt;strong&gt;高级语言（High-level Languages）&lt;/strong&gt;（如 C++、C、Python）成为了现代开发的主流。高级语言最大的突破在于它允许程序员使用接近自然语言和数学逻辑的方式编写代码。更重要的是，它通过**编译器（Compiler）**实现了代码的“可移植性”：程序员只需编写一套逻辑，编译器就能根据不同的目标机器，将其翻译成对应的机器码。这种抽象不仅让代码更易维护，还让复杂软件的协作开发成为了可能。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &lt;blockquote class=&#34;dream-alert note&#34;&gt;&#xA;    &lt;p class=&#34;heading&#34;&gt;&#xA;      &lt;ion-icon name=&#34;information-circle-outline&#34;&gt;&lt;/ion-icon&gt;Note&lt;/p&gt;&#xA;    &lt;p&gt;跨平台是高级语言与硬件脱钩后的必然产物。它将程序员从繁琐的硬件指令中解放出来，专注于逻辑表达。尽管 C++ 需要为不同平台重新编译（源码级跨平台），而 Java/Python 通过虚拟机实现（字节码级跨平台），但它们的本质逻辑是一致的：即通过一层“翻译中介”，屏蔽底层硬件差异。作为开发者，应当区分“语言特性”与“系统特性”，优先使用标准库以确保代码的可移植性。&lt;/p&gt;&#xA;  &lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;翻译的双轨制：编译器Compiler与 解释器Interpreter&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;在高级语言进化的过程中，为了平衡“运行效率”与“开发便捷性”，分化出了两种核心的翻译策略。&lt;strong&gt;编译器&lt;/strong&gt;路线（以 C/C++ 为代表）采取的是“离线翻译”模式，在程序运行前将整篇代码一次性转化为机器码。这就像翻译一本完整的书，虽然编译过程耗时，但产出的程序执行速度极快，且能在运行前通过严格的语法体检排除隐患。而&lt;strong&gt;解释器&lt;/strong&gt;路线（以 Python/LISP 为代表）则采取“同声传译”模式，在程序运行时逐行翻译并执行。这种方式虽然牺牲了部分运行性能，但换来了极高的调试效率和灵活性，允许程序员即写即看结果。&lt;/p&gt;&#xA;&lt;p&gt;如下为两种代码翻译方法的示意图：&lt;/p&gt;&#xA;&lt;p&gt;&lt;figure style=&#34;text-align: center; margin: 1.5rem auto;&#34;&gt;&#xA;  &#xA;  &lt;img src=&#34;http://localhost:1313/posts/%E3%80%90c&amp;#43;&amp;#43;%E3%80%91learncppdate/image-20260106205329384.png&#34; &#xA;       alt=&#34;a simplified representation of the compiling process&#34; &#xA;       &#xA;       class=&#34;zoomable&#34; &#xA;       style=&#34;max-width: 100%; height: auto; border-radius: 8px; cursor: zoom-in;&#34;&#xA;       loading=&#34;lazy&#34; /&gt;&#xA;  &#xA;    &lt;figcaption style=&#34;margin-top: 8px; font-size: 0.85em; color: #888; font-style: italic;&#34;&gt;&#xA;      a simplified representation of the compiling process&#xA;    &lt;/figcaption&gt;&#xA;  &#xA;&lt;/figure&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>【C&#43;&#43;】C&#43;&#43;中的设计模式</title>
      <link>http://localhost:1313/posts/c&#43;&#43;c&#43;&#43;%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 01 May 2025 00:00:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/c&#43;&#43;c&#43;&#43;%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;p&gt;设计模式是针对软件设计中反复出现问题的通用解决方案，其核心在于提升代码复用性，避免重复劳动。&lt;/p&gt;&#xA;&lt;h2 id=&#34;什么是设计模式&#34;&gt;什么是设计模式&lt;/h2&gt;&#xA;&lt;p&gt;引用**克里斯托弗·亚历山大（Christopher Alexander）**在1977年的著作《&lt;strong&gt;A Pattern Language: Towns, Buildings, Construction&lt;/strong&gt;》中提出了关于设计模式的经典定义。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;英文原版&lt;/strong&gt;：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &lt;blockquote&gt;&#xA;    &lt;p&gt;&lt;em&gt;&amp;ldquo;Each pattern describes a problem which occurs over and over again in our environment, and then describes the core of the solution to that problem, in such a way that you can use this solution a million times over, without ever doing it the same way twice.&amp;rdquo;&lt;/em&gt;&#xA;— Christopher Alexander, &lt;em&gt;A Pattern Language&lt;/em&gt;, 1977&lt;/p&gt;&#xA;&#xA;  &lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;中文翻译&lt;/strong&gt;：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &lt;blockquote&gt;&#xA;    &lt;p&gt;“每一个模式描述了一个在我们环境中反复出现的问题，并描述了该问题解决方案的核心。通过这种方式，你可以无数次地使用该解决方案，而无需以相同的方式重复两次。”&lt;/p&gt;&#xA;&#xA;  &lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;说人话就是:&lt;code&gt;不需要重复造轮子&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;推荐一本历史性著作《设计模式:可复用面相对象软件的基础》&lt;/p&gt;&#xA;&lt;p&gt;&lt;figure style=&#34;text-align: center; margin: 1.5rem auto;&#34;&gt;&#xA;  &#xA;  &lt;img src=&#34;http://localhost:1313/posts/%E3%80%90c&amp;#43;&amp;#43;%E3%80%91c&amp;#43;&amp;#43;%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E6%96%87%E7%89%88%E5%B0%81%E9%9D%A2.jpg&#34; &#xA;       alt=&#34;undefined&#34; &#xA;       &#xA;       class=&#34;zoomable&#34; &#xA;       style=&#34;max-width: 100%; height: auto; border-radius: 8px; cursor: zoom-in;&#34;&#xA;       loading=&#34;lazy&#34; /&gt;&#xA;  &#xA;    &lt;figcaption style=&#34;margin-top: 8px; font-size: 0.85em; color: #888; font-style: italic;&#34;&gt;&#xA;      undefined&#xA;    &lt;/figcaption&gt;&#xA;  &#xA;&lt;/figure&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
