<!DOCTYPE html>
<html lang="zh-cn"
  x-data
  :class="$store.darkMode.class()"
  :data-theme="$store.darkMode.theme()">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>【C&#43;&#43;】复数类与字符串类 | 古月月仔的博客</title>

    

<link rel="canonical" href="http://localhost:1313/posts/c&#43;&#43;%E5%A4%8D%E6%95%B0%E7%B1%BB%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB/" />


<meta name="author" content="古月月仔" />
<meta name="description" content="本文以Complex类为例，讲解了C&#43;&#43;程序的基本结构，包括头文件与实现文件的分离、防御性声明、命名空间的使用、inline函数的定义方式以及访问级别关键字的作用。" />
<meta name="keywords" content="语法,C&#43;&#43;,面相对象">


<meta name="generator" content="Hugo 0.153.1">

<meta property="og:url" content="http://localhost:1313/posts/c&#43;&#43;%E5%A4%8D%E6%95%B0%E7%B1%BB%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB/">
  <meta property="og:site_name" content="古月月仔的博客">
  <meta property="og:title" content="【C&#43;&#43;】复数类与字符串类">
  <meta property="og:description" content="本文以Complex类为例，讲解了C&#43;&#43;程序的基本结构，包括头文件与实现文件的分离、防御性声明、命名空间的使用、inline函数的定义方式以及访问级别关键字的作用。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-12-02T00:00:00+08:00">
    <meta property="article:modified_time" content="2025-12-02T00:00:00+08:00">
    <meta property="article:tag" content="语法">
    <meta property="article:tag" content="C&#43;&#43;">
    <meta property="article:tag" content="面相对象">



  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="【C&#43;&#43;】复数类与字符串类">
  <meta name="twitter:description" content="本文以Complex类为例，讲解了C&#43;&#43;程序的基本结构，包括头文件与实现文件的分离、防御性声明、命名空间的使用、inline函数的定义方式以及访问级别关键字的作用。">




<link rel="stylesheet" href="/css/output.css" />



<script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3/dist/cdn.min.js"></script>

    


<style>
  pre {
    padding: 1em;
    overflow: auto;
  }
</style>









    

    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3/dist/cdn.min.js" integrity="sha256-4EHxtjnR5rL8JzbY12OKQJr81ESm7JBEb49ORPo29AY=" crossorigin="anonymous"></script>
  </head>
<script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js"></script>

<style>
   
  .medium-zoom-overlay {
    z-index: 100;
    background: rgba(0, 0, 0, 0.8) !important;
  }
  .medium-zoom-image--opened {
    z-index: 101;
  }
</style>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    
    const zoom = mediumZoom('.zoomable', {
      margin: 24,          
      background: '#000',  
      scrollOffset: 40,    
    });
  });
</script>
  <body x-data="{
    flip: false,
  }">
    
    <div id="dream-global-bg"></div>

    
<nav class="mt-4 lg:mt-8 py-4">

  
  <div class="container flex justify-between px-4">
  
    <section class="flex items-center gap-4">
      <div class="avatar cursor-pointer hover:avatar-online" @click="flip = !flip" title="Flip it!">
        <div class="h-10 rounded-full">
          <img src="/img/ChipDog.jpg" alt="古月月仔的博客" />
        </div>
      </div>

      
      <div>
        
        <a href="http://localhost:1313/" class="text-lg font-semibold cursor-pointer">
          古月月仔的博客
        </a>
        
        
        <div class="text-base-content/60 text-sm">计算机在校生 || 游戏程序员
记录从基础到进阶的每一份思考。</div>
        
      </div>
      
    </section>

    
    

    <div class="dropdown dropdown-end sm:hidden">
      <div tabindex="0" role="button" class="btn btn-ghost btn-square" aria-label="Select an option">
        <ion-icon name="menu" class="text-2xl"></ion-icon>
      </div>
      <ul tabindex="0" class="dropdown-content menu w-36 bg-base-100 rounded-box z-1 shadow-md">
        







<li>
  <div role="link" tabindex="0" class="inline-flex items-center p-2 cursor-pointer" @click="flip = !flip" title="About">
    <ion-icon name="information-circle"></ion-icon>About</div>
</li>





















<li>
  <a class="inline-flex items-center p-2 cursor-pointer" href="/posts" title="Archives">
    <ion-icon name="archive"></ion-icon>
    Archives
  </a>
</li>




<li>
  <a class="inline-flex items-center p-2 cursor-pointer" href="/categories" title="All Categories">
    <ion-icon name="grid"></ion-icon>
    All Categories
  </a>
</li>




<li>
  <a class="inline-flex items-center p-2 cursor-pointer" href="/tags" title="All Tags">
    <ion-icon name="pricetags"></ion-icon>
    All Tags
  </a>
</li>






      </ul>
    </div>
    <section class="hidden sm:flex sm:items-center sm:gap-2 md:gap-4">
      

      
      




<div role="link" tabindex="0" class="text-sm font-semibold cursor-pointer hover:underline" @click="flip = !flip" title="About">About</div>





      
      





      
      





      
      
<a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary" href="/posts" title="Archives">
  <ion-icon class="group-hover:text-primary-content" name="archive"></ion-icon>
</a>


      
      
<a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary" href="/categories" title="All Categories">
  <ion-icon class="group-hover:text-primary-content" name="grid"></ion-icon>
</a>


      
      
<a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary" href="/tags" title="All Tags">
  <ion-icon class="group-hover:text-primary-content" name="pricetags"></ion-icon>
</a>


      

      

      
    </section>
  </div>
</nav>


    <div class="flip-container" :class="{ 'flip-it': flip }">
      <div class="flipper">
        <div class="front">
          <div class="container">
            
<div class="lg:grid lg:grid-cols-4 gap-4 mt-4 px-4">
  <div class="hidden lg:block">
    
  </div>

  <div class="lg:col-span-2">
    <article class="mx-auto prose prose-quoteless dark:prose-invert" id="dream-single-post-main" itemscope itemtype="http://schema.org/Article">
      
  <meta itemprop="name" content="【C&#43;&#43;】复数类与字符串类">
  <meta itemprop="description" content="本文以Complex类为例，讲解了C&#43;&#43;程序的基本结构，包括头文件与实现文件的分离、防御性声明、命名空间的使用、inline函数的定义方式以及访问级别关键字的作用。">
  <meta itemprop="datePublished" content="2025-12-02T00:00:00+08:00">
  <meta itemprop="dateModified" content="2025-12-02T00:00:00+08:00">
  <meta itemprop="wordCount" content="786">
  <meta itemprop="keywords" content="语法,C&#43;&#43;,面相对象">

      <header>
        <h1 itemprop="headline">【C&#43;&#43;】复数类与字符串类</h1>
        <p class="text-sm">
          
            Tuesday, Dec 2, 2025
          

          | <span>4 minute read</span>

          
          | <span>Updated at
            
              Tuesday, Dec 2, 2025
            </span>
          
        </p>

        
        <div class="flex justify-between">
          
            <div class="flex items-center">
  
  <span>@</span>
  

  <span itemprop="author" itemscope itemtype="https://schema.org/Person">
  
    <span itemprop="name">古月月仔</span>
  
  </span>
</div>

          

          <div class="flex items-center gap-2">
  
  

  
  
  
  
  
    <a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary"
      href="https://x.com/intent/post?text=%e3%80%90C&#43;&#43;%e3%80%91%e5%a4%8d%e6%95%b0%e7%b1%bb%e4%b8%8e%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%b1%bb&amp;url=http://localhost:1313/posts/c&#43;&#43;%E5%A4%8D%E6%95%B0%E7%B1%BB%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB/" target="_blank" rel="noopener noreferrer"
      title="Share on X">
      <ion-icon class="group-hover:text-primary-content" name="logo-x"></ion-icon>
    </a>
  
    <a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary"
      href="https://facebook.com/sharer/sharer.php?u=http://localhost:1313/posts/c&#43;&#43;%E5%A4%8D%E6%95%B0%E7%B1%BB%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB/" target="_blank" rel="noopener noreferrer"
      title="Share on Facebook">
      <ion-icon class="group-hover:text-primary-content" name="logo-facebook"></ion-icon>
    </a>
  
    <a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary"
      href="https://wa.me/?text=%e3%80%90C&#43;&#43;%e3%80%91%e5%a4%8d%e6%95%b0%e7%b1%bb%e4%b8%8e%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%b1%bb%20http://localhost:1313/posts/c&#43;&#43;%E5%A4%8D%E6%95%B0%E7%B1%BB%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB/" target="_blank" rel="noopener noreferrer"
      title="Share on WhatsApp">
      <ion-icon class="group-hover:text-primary-content" name="logo-whatsapp"></ion-icon>
    </a>
  

  
  
</div>

        </div>
      </header>

      <section id="dream-single-post-content" itemprop="articleBody">
        

        <p>本文以Complex类为例，介绍了C++程序的基本结构，包括头文件与实现文件的分离、防御性声明、命名空间的使用，以及inline函数的定义方式与注意事项。</p>
<h2 id="c-programs-代码的基本形式以complex-class为例">C++ programs 代码的基本形式(以Complex class为例)</h2>
<h3 id="头文件与类声明">头文件与类声明</h3>
<p>在写C++项目时,一般将类声明和实现分为两部分存储,即<code>.h</code>和<code>.cpp</code>文件中.<code>.cpp</code>文件中要包含<code>#inlcude</code>他的声明头文件</p>



  <blockquote class="dream-alert warning">
    <p class="heading">
      <ion-icon name="warning-outline"></ion-icon>Warning</p>
    <p>在<code>.cpp</code>文件中,自己的头文件一般用引号,而引用标准库文件则用尖括号:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include&lt;iostream.h&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#inlcude&#39;complex.h&#39;
</span></span></span></code></pre></div>
  </blockquote>

<h4 id="头文件的防御性声明">头文件的防御性声明</h4>
<p>在大型项目中,一个写好的类声明文件可能会被引用到程序的各个部分,而有一种规范安全的写法可以解决程序四处引用导致类重复声明的问题</p>
<p>示例:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#ifndef _COMPLEX_
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define _COMPLEX_
</span></span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span></code></pre></div><h4 id="namespace命名空间">namespace命名空间</h4>
<p>namesapce主要的用途是免去每个函数之前都加一个类名,举个栗子:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//使用命名空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include&lt;iostram&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    cin<span style="color:#f92672">&lt;&lt;</span>...;
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;</span>...;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//使用更加具体的命名空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include&lt;iostram&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std<span style="color:#f92672">::</span>cout;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&lt;&lt;</span>...;
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;</span>...;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//不使用命名空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include&lt;iostram&gt;
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&lt;&lt;</span>...;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>...;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="inline方式书写类">inline方式书写类</h4>
<p>对于某一个C++类,我们可以将其声明和定义直接写在一起(就是像C语音中一串写下来一样),示例:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">complex</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    complex(<span style="color:#66d9ef">double</span> r<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">double</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">:</span> re(r),im(i)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        ....
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    complex<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span> <span style="color:#f92672">+=</span>(<span style="color:#66d9ef">const</span> complex<span style="color:#f92672">&amp;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">real</span>() <span style="color:#66d9ef">const</span>{<span style="color:#66d9ef">return</span> re;}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">imag</span>() <span style="color:#66d9ef">const</span>{retrun im;}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> re,im;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">friend</span> complex<span style="color:#f92672">&amp;</span>_doapl(complex<span style="color:#f92672">*</span>,<span style="color:#66d9ef">const</span> complex<span style="color:#f92672">&amp;</span>);
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>像如上内容中,在类定义中直接将函数具体实现写在<code>{...}</code>中就是<code>inline</code>写法</p>



  <blockquote class="dream-alert caution">
    <p class="heading">
      <ion-icon name="alert-circle-outline"></ion-icon>Caution</p>
    <p>使用<code>inline</code>方式书写的函数编译之后不一定就是真正的<code>inline</code>函数,该函数只会成为一个<code>inline</code>候选,编译器会基于其复杂程度最终确定其是否为真正的<code>inline</code>,就比如上述类中的两个<code>double</code>函数,其函数内容非常简单,编译器一般会将其编译为真正的<code>inline</code>.</p>
  </blockquote>

<p>除此之外也可以向如下写法在类外定义函数,编译器检测到<code>inline</code>关键字后会将该函数与声明编译到一块</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">double</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">imag</span>(<span style="color:#66d9ef">const</span> complex<span style="color:#f92672">&amp;</span> x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> x.imag();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="access-level访问级别关键字">access level(访问级别)关键字</h3>
<p>在C++中，**访问级别（access level）**用于控制类成员（属性和方法）的可见性和可访问性，这是封装（encapsulation）的核心机制。C++提供了三个关键字来定义访问级别：<code>public</code>、<code>protected</code> 和 <code>private</code>。</p>
<p><strong><code>public</code>（公有成员）</strong></p>
<ul>
<li><strong>作用</strong>：在任何地方都可以直接访问。</li>
<li>使用场景
<ul>
<li>类的接口（供外部调用的方法）。</li>
<li>需要被全局访问的常量或工具函数。</li>
</ul>
</li>
</ul>
<p><strong><code>private</code>（私有成员）</strong></p>
<ul>
<li><strong>作用</strong>：仅在<strong>类内部</strong>或**友元（friend）**中可访问，外部代码无法直接访问。</li>
<li><strong>设计目的</strong>：隐藏实现细节，防止外部意外修改数据。</li>
</ul>
<p><strong><code>protected</code>（保护成员）</strong></p>
<ul>
<li><strong>作用</strong>：在类内部和**派生类（子类）**中可访问，外部代码不可访问。</li>
<li><strong>设计目的</strong>：支持继承时的成员共享，同时限制外部访问。</li>
</ul>
<table>
  <thead>
      <tr>
          <th>关键字</th>
          <th>类内部</th>
          <th>子类</th>
          <th>外部代码</th>
          <th>友元</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>public</code></td>
          <td>✔</td>
          <td>✔</td>
          <td>✔</td>
          <td>✔</td>
      </tr>
      <tr>
          <td><code>protected</code></td>
          <td>✔</td>
          <td>✔</td>
          <td>✖</td>
          <td>✔</td>
      </tr>
      <tr>
          <td><code>private</code></td>
          <td>✔</td>
          <td>✖</td>
          <td>✖</td>
          <td>✔</td>
      </tr>
  </tbody>
</table>
<ol>
<li><strong>默认访问级别</strong>：
<ul>
<li><strong>class</strong>：成员默认是 <code>private</code>。</li>
<li><strong>struct</strong>：成员默认是 <code>public</code>（设计初衷是兼容C的数据结构）。</li>
</ul>
</li>
<li><strong>友元（friend）</strong>：
<ul>
<li>通过 <code>friend</code> 关键字，可以允许特定函数或类突破访问限制（慎用，破坏封装性）。</li>
</ul>
</li>
<li><strong>继承时的访问控制</strong>：
<ul>
<li>派生类继承时可通过 <code>public</code>、<code>protected</code>、<code>private</code> 继承改变基类成员的访问权限（例如：<code>class Derived : private Base</code>）。</li>
</ul>
</li>
</ol>
<h3 id="构造函数与析构函数">构造函数与析构函数</h3>
<p>在C++中，<strong>构造函数（Constructor）<strong>和</strong>析构函数（Destructor）<strong>是类的特殊成员函数，分别用于对象的</strong>初始化</strong>和<strong>清理</strong>。它们是面向对象编程中资源管理的关键机制。</p>
<p>还是以之前的代码为例子:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>complex(<span style="color:#66d9ef">double</span> r <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">double</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">:</span> re(r), im(i) { ... }
</span></span></code></pre></div><ul>
<li>
<p>使用<strong>初始化列表</strong>（<code>: re(r), im(i)</code>）直接初始化成员变量（比在函数体内赋值更高效）。</p>
</li>
<li>
<p>是<strong>参数化构造函数</strong>，同时也是一个<strong>默认构造函数</strong>（因为所有参数都有默认值 <code>0</code>）。</p>
</li>
</ul>



  <blockquote class="dream-alert tip">
    <p class="heading">
      <ion-icon name="bulb-outline"></ion-icon>Tip</p>
    <p>由于我这里写的类是不带指针的,不需要显性的定义析构函数(自带的就够用),带指针的类需要手动释放资源.</p>
  </blockquote>

<h3 id="参数传递与返回值">参数传递与返回值</h3>
<h4 id="const-member-function常量成员函数">const member function(常量成员函数)</h4>
<p><code>const</code>是C++中一个非常重要的关键字，它用于定义常量、保护数据不被修改，并在编译时强制执行不变性规则。</p>
<p>还是以上面的示例:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">double</span> <span style="color:#a6e22e">real</span>() <span style="color:#66d9ef">const</span>{<span style="color:#66d9ef">return</span> re;}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">double</span> <span style="color:#a6e22e">imag</span>() <span style="color:#66d9ef">const</span>{retrun im;}
</span></span></code></pre></div><p>这样写的意义在于保证程序无论在哪种情况下都能正常使用</p>
<p>比如下面的两种调用方式:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//方式一
</span></span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    complex <span style="color:#a6e22e">c1</span>(<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;</span>c1.real();
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;</span>c1.imag();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//方式二
</span></span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> complex <span style="color:#a6e22e">c1</span>(<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;</span>c1.real();
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;</span>c1.imag();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果在类的定义中我们没有将const写在函数内容之前,那么方法二就会报错.</p>
<h4 id="函数传参pass-by-value与pass-by-referenceto-const">函数传参:pass by value与pass by reference(to const)</h4>
<p>在C++中，函数参数传递主要有两种方式：<strong>值传递</strong>和<strong>引用传递</strong>。如下示例:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">increment1</span>(<span style="color:#66d9ef">int</span> x) {
</span></span><span style="display:flex;"><span>    x<span style="color:#f92672">++</span>;  <span style="color:#75715e">// 只修改局部副本
</span></span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 普通引用传递（可修改原始数据）
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">increment2</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> x) {
</span></span><span style="display:flex;"><span>    x<span style="color:#f92672">++</span>;  <span style="color:#75715e">// 修改原始数据
</span></span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// const引用传递（不可修改原始数据）
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printLargeObject</span>(<span style="color:#66d9ef">const</span> BigObject<span style="color:#f92672">&amp;</span> obj) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 只能读取obj，不能修改
</span></span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>值传递 (Pass by Value):将实参的<strong>副本</strong>传递给函数，函数内对参数的修改不会影响原始数据。</p>
<ul>
<li>优点：
<ul>
<li>简单直接</li>
<li>不会意外修改原始数据</li>
<li>线程安全（每个线程有自己的副本）</li>
</ul>
</li>
<li>缺点：
<ul>
<li>对于大型对象（如类、结构体），复制开销大</li>
<li>无法通过参数返回额外信息</li>
</ul>
</li>
</ul>
<p>引用传递 (Pass by Reference to const):将实参的<strong>别名</strong>传递给函数，避免了复制开销。<code>const</code>引用还能保证原始数据不被修改。</p>
<ul>
<li>优点：
<ul>
<li>无复制开销，性能高</li>
<li>可以修改原始数据（非<code>const</code>引用）</li>
<li><code>const</code>引用既保证效率又保证安全性</li>
</ul>
</li>
<li>缺点：
<ul>
<li>非<code>const</code>引用可能意外修改原始数据</li>
<li>比值传递稍复杂</li>
</ul>
</li>
</ul>
<table>
  <thead>
      <tr>
          <th style="text-align: center">特性</th>
          <th style="text-align: center">值传递</th>
          <th style="text-align: center">引用传递</th>
          <th style="text-align: center">const引用传递</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center"><strong>复制开销</strong></td>
          <td style="text-align: center">有（完整复制）</td>
          <td style="text-align: center">无（传递引用）</td>
          <td style="text-align: center">无（传递引用）</td>
      </tr>
      <tr>
          <td style="text-align: center"><strong>能否修改原始数据</strong></td>
          <td style="text-align: center">不能</td>
          <td style="text-align: center">能</td>
          <td style="text-align: center">不能</td>
      </tr>
      <tr>
          <td style="text-align: center"><strong>线程安全</strong></td>
          <td style="text-align: center">安全（独立副本）</td>
          <td style="text-align: center">不安全</td>
          <td style="text-align: center">安全</td>
      </tr>
      <tr>
          <td style="text-align: center"><strong>典型用途</strong></td>
          <td style="text-align: center">小型简单数据类型</td>
          <td style="text-align: center">需要修改的参数/输出参数</td>
          <td style="text-align: center"><strong>大型只读对象</strong></td>
      </tr>
  </tbody>
</table>
<h4 id="返回值传递retrun-by-value与return-by-referenceto-const">返回值传递:retrun by value与return by reference(to const)</h4>
<p>特征与用法与上面参数传递部分基本一样,这里就不再赘述,需要注意的点是,<strong>返回引用需要保证该值的生命周期</strong>,如果无法确保生命周期可能引起灾难性的bug</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 绝对不要这样写！
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;</span> badIdea() {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>string local <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;temp&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> local; <span style="color:#75715e">// 灾难！
</span></span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="friend友元">friend友元</h4>
<p>友元是C++中一种打破封装性的特殊机制，它允许特定的<strong>非成员函数</strong>或<strong>其他类</strong>访问当前类的私有(private)和保护(protected)成员。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Engine</span>;  <span style="color:#75715e">// 前向声明
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Car</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> speed;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Engine</span>;  <span style="color:#75715e">// 允许Engine访问私有成员
</span></span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Engine</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> accelerate(Car<span style="color:#f92672">&amp;</span> car) {
</span></span><span style="display:flex;"><span>        car.speed <span style="color:#f92672">+=</span> <span style="color:#ae81ff">10</span>;  <span style="color:#75715e">// 可以访问Car的私有成员
</span></span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div>


  <blockquote class="dream-alert tip">
    <p class="heading">
      <ion-icon name="bulb-outline"></ion-icon>Tip</p>
    <p>有一个特殊写法可以理解为:相同class的各个objects互为friends(友元)</p>
<p>ps: 上面的解释是侯捷老师上课的时候给出的,查阅了的一些资料发现好像并不是这样的.</p>
  </blockquote>

<p>如下示例:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">complex</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    complex(<span style="color:#66d9ef">double</span> r<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">double</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>) <span style="color:#f92672">:</span> re(r), im(i) { }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">func</span>(<span style="color:#66d9ef">const</span> complex<span style="color:#f92672">&amp;</span> param) { 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> param.re <span style="color:#f92672">+</span> param.im; 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> re, im;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    complex c1(<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    complex c2;
</span></span><span style="display:flex;"><span>    c2.func(c1);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>此处在对象<code>c2</code>中直接访问了<code>c1</code>的私有成员,这是C++访问控制机制的一个重要特性。</p>



  <blockquote>
    <p>C++的访问控制（<code>private/protected/public</code>）是<strong>类级别</strong>的，而不是对象级别的。这意味着：</p>
<ul>
<li><strong>类的成员函数</strong>可以访问<strong>该类所有对象</strong>的私有成员（包括通过参数传入的其他对象）。</li>
<li>这种设计是为了让同类对象之间能高效协作，同时对外部代码保持封装性。</li>
</ul>

  </blockquote>

<p><strong>对比</strong></p>
<table>
  <thead>
      <tr>
          <th style="text-align: center">场景</th>
          <th style="text-align: center">能否访问私有成员？</th>
          <th style="text-align: center">原因</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center"><strong>同类成员函数访问其他对象</strong></td>
          <td style="text-align: center">✅ 可以</td>
          <td style="text-align: center">访问权限基于类（<code>complex::func</code>可以访问任何<code>complex</code>对象的私有成员）</td>
      </tr>
      <tr>
          <td style="text-align: center"><strong>外部普通函数</strong></td>
          <td style="text-align: center">❌ 不能</td>
          <td style="text-align: center">非成员函数无特权</td>
      </tr>
      <tr>
          <td style="text-align: center"><strong>友元函数</strong></td>
          <td style="text-align: center">✅ 可以</td>
          <td style="text-align: center">被类显式授权</td>
      </tr>
      <tr>
          <td style="text-align: center"><strong>派生类成员函数</strong></td>
          <td style="text-align: center">❌ 不能（除非是protected成员）</td>
          <td style="text-align: center">派生类不能访问基类私有成员</td>
      </tr>
  </tbody>
</table>
<h3 id="操作符重载">操作符重载</h3>
<h4 id="操作成员函数">操作成员函数</h4>
<p>如下代码示例:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> complex<span style="color:#f92672">&amp;</span> __doapl(complex<span style="color:#f92672">*</span> ths, <span style="color:#66d9ef">const</span> complex<span style="color:#f92672">&amp;</span> r) {
</span></span><span style="display:flex;"><span>    ths<span style="color:#f92672">-&gt;</span>re <span style="color:#f92672">+=</span> r.re;  <span style="color:#75715e">// 实部相加
</span></span></span><span style="display:flex;"><span>    ths<span style="color:#f92672">-&gt;</span>im <span style="color:#f92672">+=</span> r.im;  <span style="color:#75715e">// 虚部相加
</span></span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>ths;      <span style="color:#75715e">// 返回修改后的对象
</span></span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> complex<span style="color:#f92672">&amp;</span> complex<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">+=</span>(<span style="color:#66d9ef">const</span> complex<span style="color:#f92672">&amp;</span> r) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">__doapl</span>(<span style="color:#66d9ef">this</span>, r);  <span style="color:#75715e">// 委托给辅助函数
</span></span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>complex <span style="color:#a6e22e">a</span>(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>), b(<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>a <span style="color:#f92672">+=</span> b;  <span style="color:#75715e">// 比 a.add(b) 更符合数学直觉
</span></span></span></code></pre></div>


  <blockquote class="dream-alert caution">
    <p class="heading">
      <ion-icon name="alert-circle-outline"></ion-icon>Caution</p>
    <p>所以成员函数一定带着一个隐藏的参数<code>this</code>,但是不可以在程序中写出来,否则会报错.</p>
  </blockquote>

<p>所以其实在编辑器看来我们的运算符重载函数为:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> complex<span style="color:#f92672">&amp;</span> complex<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">+=</span>(<span style="color:#66d9ef">this</span>,<span style="color:#66d9ef">const</span> complex<span style="color:#f92672">&amp;</span> r) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">__doapl</span>(<span style="color:#66d9ef">this</span>, r);  <span style="color:#75715e">// 委托给辅助函数
</span></span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>


  <blockquote class="dream-alert caution">
    <p class="heading">
      <ion-icon name="alert-circle-outline"></ion-icon>Caution</p>
    <p>C++允许重载大多数运算符（如 <code>+</code>, <code>-</code>, <code>&lt;&lt;</code>, <code>==</code>），但不能重载以下运算符：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>.  .<span style="color:#f92672">*</span>  <span style="color:#f92672">::</span>  <span style="color:#f92672">?:</span>  <span style="color:#66d9ef">sizeof</span>  <span style="color:#960050;background-color:#1e0010">#</span>  <span style="color:#960050;background-color:#1e0010">##</span>
</span></span></code></pre></div>
  </blockquote>

<h4 id="操作非成员函数与临时对象">操作非成员函数与临时对象</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> complex <span style="color:#66d9ef">operator</span> <span style="color:#f92672">+</span> (<span style="color:#66d9ef">const</span> complex<span style="color:#f92672">&amp;</span> x, <span style="color:#66d9ef">const</span> complex<span style="color:#f92672">&amp;</span> y) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">complex</span>(real(x) <span style="color:#f92672">+</span> real(y), imag(x) <span style="color:#f92672">+</span> imag(y));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> complex <span style="color:#66d9ef">operator</span> <span style="color:#f92672">+</span> (<span style="color:#66d9ef">const</span> complex<span style="color:#f92672">&amp;</span> x, <span style="color:#66d9ef">double</span> y) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">complex</span>(real(x) <span style="color:#f92672">+</span> y, imag(x));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> complex <span style="color:#66d9ef">operator</span> <span style="color:#f92672">+</span> (<span style="color:#66d9ef">double</span> x, <span style="color:#66d9ef">const</span> complex<span style="color:#f92672">&amp;</span> y) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">complex</span>(x <span style="color:#f92672">+</span> real(y), imag(y));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如上代码可以同时处理多种复数加法运算的情况</p>



  <blockquote class="dream-alert warning">
    <p class="heading">
      <ion-icon name="warning-outline"></ion-icon>Warning</p>
    <p>上面的函数绝对不可以return by reference,因为,他们返回的必定是local object</p>
  </blockquote>

<p><code>typename( .. , ..)</code>的写法为定义一个临时对象.</p>
<h2 id="string-class">String class</h2>
<h3 id="big-three">Big Three</h3>
<p>相比上面的复数类,下面重写的String class需要特别注意三个特殊函数 <code>拷贝复制</code>,<code>拷贝构造</code>,<code>析构函数</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">String</span>    
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    String(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> cstr<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    String(<span style="color:#66d9ef">const</span> String<span style="color:#f92672">&amp;</span> str);
</span></span><span style="display:flex;"><span>    String<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> String<span style="color:#f92672">&amp;</span> str);
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">~</span>String();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">get_c_str</span>() <span style="color:#66d9ef">const</span>{<span style="color:#66d9ef">return</span> m_data;}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> m_data;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h4 id="ctor和dtor构造函数-和-析构函数">ctor和dtor(构造函数 和 析构函数)</h4>
<p>class中如果有指针,那么该类的变量中多半使用了动态内存分配,要再析构函数中将该内存释放掉,否则会造成<strong>内存泄漏</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">inline</span>
</span></span><span style="display:flex;"><span>String<span style="color:#f92672">::</span>string(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> cstr<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(cstr){
</span></span><span style="display:flex;"><span>        m_data<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span>[strlen(cstr)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        strcpy(m_data,cstr);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>{<span style="color:#75715e">//未指定初始值的情况
</span></span></span><span style="display:flex;"><span>        m_data<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span>[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>m_data<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;\0&#39;</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span>
</span></span><span style="display:flex;"><span>String<span style="color:#f92672">::~</span>String()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">delete</span>[] m_data;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="copy-ctor和copy-op-拷贝构造和拷贝赋值">copy ctor和copy op= (拷贝构造和拷贝赋值)</h4>



  <blockquote class="dream-alert caution">
    <p class="heading">
      <ion-icon name="alert-circle-outline"></ion-icon>Caution</p>
    <p>class with  pointer members类中存在指针变量成员,则必须为其书写特殊的<code>copy ctor</code>和<code>copy op =</code></p>
  </blockquote>

<p><strong>浅拷贝和深拷贝</strong></p>
<p>如果指针类的变量直接使用默认的copy,则会造成两个变量同时指向一个地址(其实就是别名),而且原本内存泄漏掉</p>
<p><figure style="text-align: center; margin: 1.5rem auto;">
  
  <img src="http://localhost:1313/posts/c&#43;&#43;%E5%A4%8D%E6%95%B0%E7%B1%BB%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB/%E3%80%90c&#43;&#43;%E3%80%91%E5%A4%8D%E6%95%B0%E7%B1%BB%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB/image-20250511153941283.png" 
       alt="image-20250511153941283" 
       
       class="zoomable" 
       style="max-width: 100%; height: auto; border-radius: 8px; cursor: zoom-in;"
       loading="lazy" />
  
    <figcaption style="margin-top: 8px; font-size: 0.85em; color: #888; font-style: italic;">
      image-20250511153941283
    </figcaption>
  
</figure></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">inline</span>
</span></span><span style="display:flex;"><span>String<span style="color:#f92672">::</span>String(<span style="color:#66d9ef">const</span> String<span style="color:#f92672">&amp;</span> str)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    m_data <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span>[ strlen(str.m_data)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>];<span style="color:#75715e">//同类型的对象可以直接取另一个的object的private data.
</span></span></span><span style="display:flex;"><span>    strcpy(m_data,str.m_data);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//下面为使用场景
</span></span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    String <span style="color:#a6e22e">s1</span>(<span style="color:#e6db74">&#34;Hello&#34;</span>);
</span></span><span style="display:flex;"><span>    String <span style="color:#a6e22e">s2</span>(s1);
</span></span><span style="display:flex;"><span>    String s2<span style="color:#f92672">=</span>s1;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">inline</span>
</span></span><span style="display:flex;"><span>String<span style="color:#f92672">&amp;</span> String<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> String<span style="color:#f92672">&amp;</span> str)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(<span style="color:#66d9ef">this</span><span style="color:#f92672">==&amp;</span>str)<span style="color:#75715e">//检测自我赋值,是十分有必要的,因为后续的逻辑会清除原本self的地址空间
</span></span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">delete</span>[] m_data;
</span></span><span style="display:flex;"><span>    m_data <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span>[ strlen(str.m_data)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    strcpy(m_data,str.m_data);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    String <span style="color:#a6e22e">s1</span>(<span style="color:#e6db74">&#34;Hello&#34;</span>);
</span></span><span style="display:flex;"><span>    String <span style="color:#a6e22e">s2</span>(s1);
</span></span><span style="display:flex;"><span>   	s2<span style="color:#f92672">=</span>s1;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="输出cout">输出cout</h3>
<p>全局函数,在<code>cout</code>的定义部分重载<code>&lt;&lt;</code>符号,如下图所示:
<figure style="text-align: center; margin: 1.5rem auto;">
  
  <img src="http://localhost:1313/posts/%E3%80%90c&#43;&#43;%E3%80%91%E5%A4%8D%E6%95%B0%E7%B1%BB%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB/image-20250511223901096.png" 
       alt="image-20250511223901096" 
       
       class="zoomable" 
       style="max-width: 100%; height: auto; border-radius: 8px; cursor: zoom-in;"
       loading="lazy" />
  
    <figcaption style="margin-top: 8px; font-size: 0.85em; color: #888; font-style: italic;">
      image-20250511223901096
    </figcaption>
  
</figure></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#inlcude&lt;istream.h&gt;
</span></span></span><span style="display:flex;"><span>ostream<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;&lt;</span>(ostream<span style="color:#f92672">&amp;</span> os,<span style="color:#66d9ef">const</span> String<span style="color:#f92672">&amp;</span> str)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    os<span style="color:#f92672">&lt;&lt;</span>str.get_c_str();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> os;<span style="color:#75715e">//返回os类型,用于符合用户书写习惯在后面跟其他的东西.
</span></span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    String <span style="color:#a6e22e">s1</span>(<span style="color:#e6db74">&#34;hello &#34;</span>);
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;</span>s1;
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;</span>s1<span style="color:#f92672">&lt;&lt;</span>endl;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="class-template类模板">class template类模板</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">complex</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    complex(T r<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;T i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">:</span>re(r),im(i)
</span></span><span style="display:flex;"><span>    {}
</span></span><span style="display:flex;"><span>    complex<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span> <span style="color:#f92672">+=</span>(<span style="color:#66d9ef">const</span> complex<span style="color:#f92672">&amp;</span>);
</span></span><span style="display:flex;"><span>    T <span style="color:#a6e22e">real</span>()<span style="color:#66d9ef">const</span>{<span style="color:#66d9ef">return</span> re;}
</span></span><span style="display:flex;"><span>    T <span style="color:#a6e22e">imag</span>()<span style="color:#66d9ef">const</span>{<span style="color:#66d9ef">return</span> im;}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    T re,im;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">friend</span> complex<span style="color:#f92672">&amp;</span> _doapl(complex<span style="color:#f92672">*</span>,<span style="color:#66d9ef">const</span> complex<span style="color:#f92672">&amp;</span>);
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">\\使用模板创建类</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    complex<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span>c1(<span style="color:#ae81ff">2.5</span>,<span style="color:#ae81ff">1.5</span>);
</span></span><span style="display:flex;"><span>    complex<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>c2(<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">6</span>);
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>类模板可以使<em><strong>代码膨胀</strong></em>,一次书写,多次使用.</p>
<h2 id="function-template函数模板">function template函数模板</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> min(<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> a,<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> b<span style="color:#f92672">&lt;</span>a<span style="color:#f92672">?</span>b:a;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//某一个类定义
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">stone</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    stone(<span style="color:#66d9ef">int</span> w,<span style="color:#66d9ef">int</span> h,<span style="color:#66d9ef">int</span> we)
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">:</span> _w(w), _h(h), _weight(we)
</span></span><span style="display:flex;"><span>        {}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;</span> (<span style="color:#66d9ef">const</span> stone<span style="color:#f92672">&amp;</span> rhs) <span style="color:#66d9ef">const</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> _weight<span style="color:#f92672">&lt;</span>rhs._weight;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> _w, _h, _weight;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//具体使用
</span></span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    stone <span style="color:#a6e22e">r1</span>(<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>),r2(<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">3</span>),r3;
</span></span><span style="display:flex;"><span>    r3<span style="color:#f92672">=</span>min(r1,r2);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>对于上面的函数模板使用,编译器首先会对function template进行参数推导（Argument Deduction）,参数推导的结果是<code>T</code>为<code>stone</code>,于是调用<code>stone::operator&lt;</code>,如果该类没有实现<code>&lt;</code>的重载则会报错.</p>


        
      </section>

      

      
    </article>
  </div>

  <div
    x-data="tocHighlighter()"
    @scroll.window="debouncedScroll"
    class="hidden lg:flex lg:flex-col lg:items-end lg:self-start"
  >
    
  </div>
</div>


            
<footer class="flex justify-between items-center gap-2 px-4 py-12">

  <div>
  
  <p>
    © 2021 - 2026 古月月仔的博客
  </p>
  

  
  <p class="text-sm">
    🌱
    <span class="text-base-content/60">
      Powered by <a class="hover:underline" href="https://gohugo.io/" target="_blank">Hugo</a> with theme
      <a class="hover:underline" href="https://github.com/g1eny0ung/hugo-theme-dream" target="_blank">Dream</a>.</span
    >
  </p>
  
</div>

  <div
  x-data="{ icons: [
    { name: 'sunny', status: 'n' },
    { name: 'moon', status: 'y' },
    { name: 'desktop', status: 'auto' }
  ] }"
  class="flex items-center gap-2 h-[32px] px-2 bg-base-100 border border-base-content/30 rounded-full"
>
  <template x-for="icon in icons">
    <div
      role="button"
      tabindex="0"
      :aria-label="'Select ' + icon.name + ' mode'"
      class="group inline-flex justify-center items-center p-1 rounded-full cursor-pointer hover:bg-primary"
      :class="$store.darkMode.icon() === icon.name && 'bg-primary'"
      @click="$store.darkMode.toggle(icon.status)"
    >
      <ion-icon
        :name="`${icon.name}-outline`"
        class="group-hover:text-primary-content"
        :class="$store.darkMode.icon() === icon.name && 'text-primary-content'"
      >
      </ion-icon>
    </div>
  </template>
</div>

</footer>

          </div>
        </div>
        <div class="back">
          <div class="container">
            
            <div class="dream-grid dream-grid-about">
  
  
  
  <div class="w-full md:w-1/2 lg:w-1/3 xl:w-1/4 p-4 dream-column">
    <article
      class="card bg-base-100 hover:bg-base-content/10 shadow-xl dark:border dark:border-base-content/30"
    >
      <div class="card-body">
        <div class="card-title">关于我</div>

        <div class="prose dark:prose-invert">
          <ul>
<li>我是<strong>古月月仔</strong></li>
<li><strong>Ethan Hu</strong></li>
<li>分享技术学习笔记与生活点滴</li>
<li><strong>现居</strong>： 上海 中国</li>
<li><strong>家乡</strong>： 平遥 山西</li>
</ul>

        </div>
      </div>
    </article>
  </div>
  
  <div class="w-full md:w-1/2 lg:w-1/3 xl:w-1/4 p-4 dream-column">
    <article
      class="card bg-base-100 hover:bg-base-content/10 shadow-xl dark:border dark:border-base-content/30"
    >
      <div class="card-body">
        <div class="card-title">在用的学习工具</div>

        <div class="prose dark:prose-invert">
          <ul>
<li>📝 <a href="https://typora.io/" target="_blank">Typora</a>
 —— 极致简洁的 Markdown 编辑器，助力沉浸式文档撰写与知识记录。</li>
<li>📓 <a href="https://www.notion.so/" target="_blank">Notion</a>
 —— 一站式工作空间，用于搭建个人知识库、项目管理与深度协作。</li>
<li>🔗 <a href="https://n8n.io/" target="_blank">N8N</a>
 —— 强大的基于节点的自动化工作流工具，轻松实现不同应用间的逻辑联动。</li>
<li>🤖 <a href="https://gemini.google.com/" target="_blank">Gemini</a>
 —— 智能 AI 助手，在代码辅助、创意激发与信息检索中提供强力支撑。</li>
</ul>

        </div>
      </div>
    </article>
  </div>
  
  <div class="w-full md:w-1/2 lg:w-1/3 xl:w-1/4 p-4 dream-column">
    <article
      class="card bg-base-100 hover:bg-base-content/10 shadow-xl dark:border dark:border-base-content/30"
    >
      <div class="card-body">
        <div class="card-title">我的爱好</div>

        <div class="prose dark:prose-invert">
          <ul>
<li>🚀 喜欢折腾各种好玩的技术</li>
<li>📸 业余摄影爱好者</li>
<li>🎮 各类游戏玩家</li>
<li>💻 数码产品折腾爱好者</li>
<li>📚 阅读：赫尔曼·黑塞 &amp; 阿尔贝·加缪</li>
<li>🎞️ 追番中：《电锯人：蕾塞篇》</li>
<li>🎬 经典重温：《命运石之门》</li>
</ul>

        </div>
      </div>
    </article>
  </div>
  
  <div class="w-full md:w-1/2 lg:w-1/3 xl:w-1/4 p-4 dream-column">
    <article
      class="card bg-base-100 hover:bg-base-content/10 shadow-xl dark:border dark:border-base-content/30"
    >
      <div class="card-body">
        <div class="card-title">最近正在学</div>

        <div class="prose dark:prose-invert">
          <ul>
<li>🎨 <a href="https://games104.boomingtech.com/" target="_blank">GAMES104</a>
 —— 现代游戏引擎入门。</li>
<li>🏔️ <a href="https://www.sidefx.com/learn/" target="_blank">Houdini 基础</a>
 —— 学习程序化建模与特效。</li>
<li>🤗 <a href="https://huggingface.co/learn" target="_blank">Hugging Face</a>
 —— 探索开源 AI 社区。</li>
</ul>

        </div>
      </div>
    </article>
  </div>
  
  

  

  
</div>

            

            
<footer class="flex justify-between items-center gap-2 px-4 py-12">

  <div>
  
  <p>
    © 2021 - 2026 古月月仔的博客
  </p>
  

  
  <p class="text-sm">
    🌱
    <span class="text-base-content/60">
      Powered by <a class="hover:underline" href="https://gohugo.io/" target="_blank">Hugo</a> with theme
      <a class="hover:underline" href="https://github.com/g1eny0ung/hugo-theme-dream" target="_blank">Dream</a>.</span
    >
  </p>
  
</div>

  <div
  x-data="{ icons: [
    { name: 'sunny', status: 'n' },
    { name: 'moon', status: 'y' },
    { name: 'desktop', status: 'auto' }
  ] }"
  class="flex items-center gap-2 h-[32px] px-2 bg-base-100 border border-base-content/30 rounded-full"
>
  <template x-for="icon in icons">
    <div
      role="button"
      tabindex="0"
      :aria-label="'Select ' + icon.name + ' mode'"
      class="group inline-flex justify-center items-center p-1 rounded-full cursor-pointer hover:bg-primary"
      :class="$store.darkMode.icon() === icon.name && 'bg-primary'"
      @click="$store.darkMode.toggle(icon.status)"
    >
      <ion-icon
        :name="`${icon.name}-outline`"
        class="group-hover:text-primary-content"
        :class="$store.darkMode.icon() === icon.name && 'text-primary-content'"
      >
      </ion-icon>
    </div>
  </template>
</div>

</footer>

          </div>
        </div>
      </div>
    </div>

    <script>
  window.lightTheme = "emerald"
  window.darkTheme = "forest"
</script>


  <script src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js"></script>

  
  
  <script src="/js/grid.js"></script>




<script src="/js/main.js"></script>
    







<script src="/js/toc.js"></script>




  




    

    
      <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [
        ['\\[', '\\]'],
        ['$$', '$$'],
      ], 
      inlineMath: [
        ['\\(', '\\)'],
        ['$', '$'],
      ], 
    },
  }
</script>

    

    

    

    <script type="module" src="https://cdn.jsdelivr.net/npm/ionicons@7.4.0/dist/ionicons/ionicons.esm.js" integrity="sha256-/IFmi82bIhdYWctu0UddSlJqpnzWm7Vh2C4CM32wF/k=" crossorigin="anonymous"></script>
    <script nomodule src="https://cdn.jsdelivr.net/npm/ionicons@7.4.0/dist/ionicons/ionicons.js" integrity="sha256-mr7eJMX3VC3F7G32mk4oWp1C6a2tlMYxUdptfT7uKI8=" crossorigin="anonymous"></script>
  </body>
</html>
