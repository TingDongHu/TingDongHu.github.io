<!DOCTYPE html>
<html lang="zh-cn"
  x-data
  :class="$store.darkMode.class()"
  :data-theme="$store.darkMode.theme()">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>【C&#43;&#43;】组合、继承和多态 | 古月月仔的博客</title>

    

<link rel="canonical" href="http://localhost:1313/posts/c&#43;&#43;%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/" />


<meta name="author" content="古月月仔" />
<meta name="description" content="组合（Composition）、继承（Inheritance）和多态（Polymorphism）是C&#43;&#43;中面向对象编程（OOP）的三大支柱。本文从内存管理的角度深入挖掘了这三大支柱的细节。" />
<meta name="keywords" content="面相对象,C&#43;&#43;,继承,多态,虚函数">


<meta name="generator" content="Hugo 0.153.1">

<meta property="og:url" content="http://localhost:1313/posts/c&#43;&#43;%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/">
  <meta property="og:site_name" content="古月月仔的博客">
  <meta property="og:title" content="【C&#43;&#43;】组合、继承和多态">
  <meta property="og:description" content="组合（Composition）、继承（Inheritance）和多态（Polymorphism）是C&#43;&#43;中面向对象编程（OOP）的三大支柱。本文从内存管理的角度深入挖掘了这三大支柱的细节。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2026-01-05T00:00:00+08:00">
    <meta property="article:modified_time" content="2026-01-05T00:00:00+08:00">
    <meta property="article:tag" content="面相对象">
    <meta property="article:tag" content="C&#43;&#43;">
    <meta property="article:tag" content="继承">
    <meta property="article:tag" content="多态">
    <meta property="article:tag" content="虚函数">



  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="【C&#43;&#43;】组合、继承和多态">
  <meta name="twitter:description" content="组合（Composition）、继承（Inheritance）和多态（Polymorphism）是C&#43;&#43;中面向对象编程（OOP）的三大支柱。本文从内存管理的角度深入挖掘了这三大支柱的细节。">




<link rel="stylesheet" href="/css/output.css" />



<script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3/dist/cdn.min.js"></script>
<link rel="stylesheet" href="/css/custom.css">
<script src="/js/code_block.js" defer></script>

    


<style>
  pre {
    padding: 1em;
    overflow: auto;
  }
</style>









    

    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3/dist/cdn.min.js" integrity="sha256-4EHxtjnR5rL8JzbY12OKQJr81ESm7JBEb49ORPo29AY=" crossorigin="anonymous"></script>
  </head>
<script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js"></script>

<style>
   
  .medium-zoom-overlay {
    z-index: 100;
    background: rgba(0, 0, 0, 0.8) !important;
  }
  .medium-zoom-image--opened {
    z-index: 101;
  }
</style>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    
    const zoom = mediumZoom('.zoomable', {
      margin: 24,          
      background: '#000',  
      scrollOffset: 40,    
    });
  });
</script>
  <body x-data="{
    flip: false,
  }">
    
    <div id="dream-global-bg"></div>

    
<nav class="mt-4 lg:mt-8 py-4">

  
  <div class="container flex justify-between px-4">
  
    <section class="flex items-center gap-4">
      <div class="avatar cursor-pointer hover:avatar-online" @click="flip = !flip" title="Flip it!">
        <div class="h-10 rounded-full">
          <img src="/img/ChipDog.jpg" alt="古月月仔的博客" />
        </div>
      </div>

      
      <div>
        
        <a href="http://localhost:1313/" class="text-lg font-semibold cursor-pointer">
          古月月仔的博客
        </a>
        
        
        <div class="text-base-content/60 text-sm">计算机在校生 || 游戏程序员
记录从基础到进阶的每一份思考。</div>
        
      </div>
      
    </section>

    
    

    <div class="dropdown dropdown-end sm:hidden">
      <div tabindex="0" role="button" class="btn btn-ghost btn-square" aria-label="Select an option">
        <ion-icon name="menu" class="text-2xl"></ion-icon>
      </div>
      <ul tabindex="0" class="dropdown-content menu w-36 bg-base-100 rounded-box z-1 shadow-md">
        







<li>
  <div role="link" tabindex="0" class="inline-flex items-center p-2 cursor-pointer" @click="flip = !flip" title="About">
    <ion-icon name="information-circle"></ion-icon>About</div>
</li>





















<li>
  <a class="inline-flex items-center p-2 cursor-pointer" href="/posts" title="Archives">
    <ion-icon name="archive"></ion-icon>
    Archives
  </a>
</li>




<li>
  <a class="inline-flex items-center p-2 cursor-pointer" href="/categories" title="All Categories">
    <ion-icon name="grid"></ion-icon>
    All Categories
  </a>
</li>




<li>
  <a class="inline-flex items-center p-2 cursor-pointer" href="/tags" title="All Tags">
    <ion-icon name="pricetags"></ion-icon>
    All Tags
  </a>
</li>






      </ul>
    </div>
    <section class="hidden sm:flex sm:items-center sm:gap-2 md:gap-4">
      

      
      




<div role="link" tabindex="0" class="text-sm font-semibold cursor-pointer hover:underline" @click="flip = !flip" title="About">About</div>





      
      





      
      





      
      
<a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary" href="/posts" title="Archives">
  <ion-icon class="group-hover:text-primary-content" name="archive"></ion-icon>
</a>


      
      
<a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary" href="/categories" title="All Categories">
  <ion-icon class="group-hover:text-primary-content" name="grid"></ion-icon>
</a>


      
      
<a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary" href="/tags" title="All Tags">
  <ion-icon class="group-hover:text-primary-content" name="pricetags"></ion-icon>
</a>


      

      

      
    </section>
  </div>
</nav>


    <div class="flip-container" :class="{ 'flip-it': flip }">
      <div class="flipper">
        <div class="front">
          <div class="container">
            
<div class="lg:grid lg:grid-cols-4 gap-4 mt-4 px-4">
  <div class="hidden lg:block">
    
  </div>

  <div class="lg:col-span-2">
    <article class="mx-auto prose prose-quoteless dark:prose-invert" id="dream-single-post-main" itemscope itemtype="http://schema.org/Article">
      
  <meta itemprop="name" content="【C&#43;&#43;】组合、继承和多态">
  <meta itemprop="description" content="组合（Composition）、继承（Inheritance）和多态（Polymorphism）是C&#43;&#43;中面向对象编程（OOP）的三大支柱。本文从内存管理的角度深入挖掘了这三大支柱的细节。">
  <meta itemprop="datePublished" content="2026-01-05T00:00:00+08:00">
  <meta itemprop="dateModified" content="2026-01-05T00:00:00+08:00">
  <meta itemprop="wordCount" content="1649">
  <meta itemprop="keywords" content="面相对象,C&#43;&#43;,继承,多态,虚函数">

      <header>
        <h1 itemprop="headline">【C&#43;&#43;】组合、继承和多态</h1>
        <p class="text-sm">
          
            Monday, Jan 5, 2026
          

          | <span>8 minute read</span>

          
          | <span>Updated at
            
              Monday, Jan 5, 2026
            </span>
          
        </p>

        
        <div class="flex justify-between">
          
            <div class="flex items-center">
  
  <span>@</span>
  

  <span itemprop="author" itemscope itemtype="https://schema.org/Person">
  
    <span itemprop="name">古月月仔</span>
  
  </span>
</div>

          

          <div class="flex items-center gap-2">
  
  

  
  
  
  
  
    <a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary"
      href="https://x.com/intent/post?text=%e3%80%90C&#43;&#43;%e3%80%91%e7%bb%84%e5%90%88%e3%80%81%e7%bb%a7%e6%89%bf%e5%92%8c%e5%a4%9a%e6%80%81&amp;url=http://localhost:1313/posts/c&#43;&#43;%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/" target="_blank" rel="noopener noreferrer"
      title="Share on X">
      <ion-icon class="group-hover:text-primary-content" name="logo-x"></ion-icon>
    </a>
  
    <a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary"
      href="https://facebook.com/sharer/sharer.php?u=http://localhost:1313/posts/c&#43;&#43;%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/" target="_blank" rel="noopener noreferrer"
      title="Share on Facebook">
      <ion-icon class="group-hover:text-primary-content" name="logo-facebook"></ion-icon>
    </a>
  
    <a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary"
      href="https://wa.me/?text=%e3%80%90C&#43;&#43;%e3%80%91%e7%bb%84%e5%90%88%e3%80%81%e7%bb%a7%e6%89%bf%e5%92%8c%e5%a4%9a%e6%80%81%20http://localhost:1313/posts/c&#43;&#43;%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/" target="_blank" rel="noopener noreferrer"
      title="Share on WhatsApp">
      <ion-icon class="group-hover:text-primary-content" name="logo-whatsapp"></ion-icon>
    </a>
  

  
  
</div>

        </div>
      </header>

      <section id="dream-single-post-content" itemprop="articleBody">
        

        <p>组合（Composition）、继承（Inheritance）和多态（Polymorphism）是C++中面向对象编程（OOP）的三大支柱。</p>
<p>之前只在大学课本上学到一点皮毛，在此做复习和深入挖掘。</p>
<h2 id="组合-composition物理嵌套与高效复用">组合 (Composition)物理嵌套与高效复用</h2>
<p><strong>组合</strong>描述的是一种“有一个 (Has-a)”的关系。在 C++ 中，当我们将一个类的对象作为另一个类的数据成员时，就形成了组合。</p>
<p>从内存布局的角度来看，组合体现为<strong>物理上的直接嵌套</strong>：成员对象的所有数据成员被完整地包含在宿主对象的内存空间内。这意味着，如果你在栈上创建一个宿主对象，其组合的所有成员也都在栈上；同理，若宿主在堆上，成员也在堆上。</p>
<p>这种布局方式带来了极高的执行效率，因为数据在内存中是连续存放的，极大提高了 CPU 的缓存命中率。</p>
<p>在初始化逻辑上，C++ 遵循严格的顺序：<strong>成员对象先构造，宿主对象后构造</strong>；析构时则完全相反。设计上，C++ 社区推崇“优先使用组合而非继承”，因为组合是一种“黑盒复用”，宿主类只需关心成员类的公共接口，而不需要了解其内部实现，这大大降低了代码间的耦合度。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Engine</span> <span class="p">{</span> <span class="cm">/* 引擎数据 */</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Car</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Engine</span> <span class="n">engine</span><span class="p">;</span> <span class="c1">// Car 组合了 Engine
</span></span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果你在栈上创建一个 <code>Car</code> 对象，那么 <code>Engine</code> 的数据会<strong>直接包含</strong>在 <code>Car</code> 的内存块内部。</p>
<p><strong>设计原则</strong>：<strong>优先使用组合，而不是继承</strong>。组合耦合度低，灵活性高。</p>
<p><strong>生命周期</strong>：成员对象（Engine）随宿主对象（Car）的创建而创建，随其销毁而销毁。</p>
<h2 id="继承-inheritance结构延伸与逻辑分类">继承 (Inheritance)：结构延伸与逻辑分类</h2>
<p><strong>继承</strong>建立的是一种“是一个 (Is-a)”的关系，允许你基于已有的类创建新类，从而复用代码。它允许子类继承父类的属性和行为。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Animal</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">eat</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Eating...&#34;</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Cat</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span> <span class="p">{</span> <span class="c1">// Cat 继承自 Animal
</span></span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">meow</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Meow!&#34;</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>派生类（Cat）的内存结构是：<strong>父类的数据成员 + 派生类特有的数据成员</strong>。</p>
<p><strong>核心逻辑</strong>：</p>
<ul>
<li><strong>可见性</strong>：<code>public</code> 继承表示父类的公有成员在子类中依然公有。</li>
<li><strong>构造顺序</strong>：先调用父类构造函数，再调用子类构造函数。析构顺序则相反。</li>
</ul>
<p>在内存层面，继承表现为<strong>结构的延伸</strong>：子类对象的内存块头部通常包含了一个完整的父类对象副本，随后才是子类特有的数据成员。这种“头部对齐”的特性使得父类指针能够安全地指向子类对象的起始地址。</p>
<p>继承被称为“白盒复用”，因为子类往往能够看到父类的 <code>protected</code> 成员，这虽然增强了灵活性，但也导致了较高的耦合——父类的任何微小改动都可能波及整个继承链。</p>
<p>C++ 的继承体系遵循**“先父后子”**的构造原则：系统必须先确保基类部分初始化完成，才能开始子类部分的构建。</p>
<h3 id="菱形继承问题与虚继承">菱形继承问题与虚继承</h3>
<p>当一个类（基类 A）被两个子类（B 和 C）继承，而又有一个类（D）同时继承这两个子类时，继承图的形状就像一个菱形。</p>



  <blockquote>
    <p>举个栗子：</p>
<ul>
<li><strong>Person (人)</strong>：基类</li>
<li><strong>Student (学生)</strong>：继承自 Person</li>
<li><strong>Teacher (老师)</strong>：继承自 Person</li>
<li><strong>TeachingAssistant (助教)</strong>：既是学生也是老师，同时继承自 Student 和 Teacher</li>
</ul>

  </blockquote>

<p><strong>二义性与冗余</strong></p>
<p>如果不做特殊处理，菱形继承会导致严重的内存问题。我们来看这段会报错的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Person</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Student</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Person</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Teacher</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Person</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">TA</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Student</span><span class="p">,</span> <span class="k">public</span> <span class="n">Teacher</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">TA</span> <span class="n">ta</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ta.name = &#34;小明&#34;; // 报错！编译失败：二义性 (ambiguous)
</span></span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 你必须这样写，编译器才知道你要改哪个“分身”的名字：
</span></span></span><span class="line"><span class="cl">    <span class="n">ta</span><span class="p">.</span><span class="n">Student</span><span class="o">::</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#34;学生小明&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ta</span><span class="p">.</span><span class="n">Teacher</span><span class="o">::</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#34;老师小明&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在内存中，<code>TA</code> 对象内部包含了两个 <code>Person</code> 的副本：</p>
<ol>
<li>一个是从 <code>Student</code> 路径继承下来的 <code>Person</code>。</li>
<li>一个是从 <code>Teacher</code> 路径继承下来的 <code>Person</code></li>
</ol>
<p><strong>二义性</strong>：当你访问 <code>ta.name</code> 时，编译器不知道你是要访问 Student 里的 name 还是 Teacher 里的 name。</p>
<p><strong>资源浪费</strong>：如果 <code>Person</code> 很大（比如包含 100MB 的头像数据），那么 <code>TA</code> 对象就会无谓地占用 200MB 内存。</p>
<h4 id="虚继承-virtual-inheritance">虚继承 (Virtual Inheritance)</h4>
<p>为了解决这个问题，C++ 引入了 <strong>虚继承</strong>。我们只需要在中间层（Student 和 Teacher）继承时加上 <code>virtual</code> 关键字。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Person</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Person</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;构造了一个 Person</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 【关键】虚继承
</span></span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Student</span> <span class="o">:</span> <span class="k">virtual</span> <span class="k">public</span> <span class="n">Person</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Teacher</span> <span class="o">:</span> <span class="k">virtual</span> <span class="k">public</span> <span class="n">Person</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">TA</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Student</span><span class="p">,</span> <span class="k">public</span> <span class="n">Teacher</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">TA</span> <span class="n">ta</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ta</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#34;小明&#34;</span><span class="p">;</span> <span class="c1">// 现在成功了！全局唯一
</span></span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;TA 的名字是: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">ta</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="虚基类指针-vbptr">虚基类指针 (vbptr)</h4>
<p>当你使用了 <code>virtual</code> 继承，内存布局发生了翻天覆地的变化：</p>
<ol>
<li><strong>内存合并</strong>：编译器不再把 <code>Person</code> 放在 <code>Student</code> 和 <code>Teacher</code> 的“身体里”，而是把唯一的 <code>Person</code> 放在内存的<strong>最末端</strong>（作为公共资源）。</li>
<li><strong>引入指针</strong>：<code>Student</code> 和 <code>Teacher</code> 内部不再存 <code>Person</code> 的数据，而是各存了一个 <strong>虚基类指针 (vbptr, virtual base pointer)</strong>。</li>
<li><strong>查找偏移</strong>：这个指针指向一张 <strong>虚基类表 (vbtable)</strong>，表里记录了“从当前位置到公共 <code>Person</code> 数据的距离（偏移量）”。</li>
</ol>
<p>如下列示例代码所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 基类：4 字节
</span></span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">data</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// --- 情况 1：普通菱形继承 ---
</span></span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A1</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">B1</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C1</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A1</span><span class="p">,</span> <span class="k">public</span> <span class="n">B1</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// --- 情况 2：虚继承 ---
</span></span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A2</span> <span class="o">:</span> <span class="k">virtual</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">B2</span> <span class="o">:</span> <span class="k">virtual</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C2</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A2</span><span class="p">,</span> <span class="k">public</span> <span class="n">B2</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;--- 普通继承 ---&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Base 大小: &#34;</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Base</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;A1 (普通) 大小: &#34;</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">A1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;C1 (普通) 大小: &#34;</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">C1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">--- 虚继承 ---&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;A2 (虚继承) 大小: &#34;</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">A2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;C2 (虚继承) 大小: &#34;</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">C2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>运行后会发现：</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left"><strong>类</strong></th>
          <th><strong>大小 (Bytes)</strong></th>
          <th><strong>内存组成拆解</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><strong>Base</strong></td>
          <td><strong>4</strong></td>
          <td>1 个 <code>int</code></td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>A1</strong> (普通)</td>
          <td><strong>4</strong></td>
          <td>继承了 Base 的 1 个 <code>int</code></td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>C1</strong> (普通)</td>
          <td><strong>8</strong></td>
          <td>A1 的 <code>int</code> + B1 的 <code>int</code> (冗余了！)</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>A2</strong> (虚)</td>
          <td><strong>12 或 16</strong></td>
          <td><strong>vbptr (8字节)</strong> + Base 的 <code>int</code> (4字节) + 补齐</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>C2</strong> (虚)</td>
          <td><strong>24 或 32</strong></td>
          <td><strong>A2的vbptr + B2的vbptr + 唯一的Base(int)</strong></td>
      </tr>
  </tbody>
</table>
<p>虚继承不是为了消除冗余吗？为什么 C2 反而比 C1 大这么多？</p>
<p><strong>空间换唯一性</strong>：虽然我们消除了重复的 <code>Base::data</code>，但为了能在运行时找到那个唯一的 <code>Base</code>，编译器不得不给每个参与虚继承的对象塞进一个 <strong>虚基类指针 (vbptr)</strong>。</p>
<p><strong>指针的代价</strong>：在 64 位系统下，一个指针就是 8 字节。在我们的例子中，<code>Base</code> 本身才 4 字节。为了节省 4 字节的冗余，我们引入了 8 字节的指针。</p>
<p>当你在内存中观察 <code>C2</code> 对象时，它的排布大约是这样的：</p>
<ul>
<li><strong>[ 0 - 7 字节 ]</strong>: <code>vbptr</code> (属于 A2 部分)，指向一张偏移量表。</li>
<li><strong>[ 8 - 15 字节 ]</strong>: <code>vbptr</code> (属于 B2 部分)，指向另一张偏移量表。</li>
<li><strong>[ 16 - 19 字节 ]</strong>: <strong>唯一的 Base::data</strong>。它是被“共享”的。</li>
<li><strong>[ 20 - 23 字节 ]</strong>: 内存填充（Padding），为了对齐。</li>
</ul>
<p><strong>这就是为什么它叫“虚”继承：</strong> 在普通继承中，父类就在子类的“身体”里，位置是死的； 在虚继承中，父类被踢到了对象的末尾，子类通过指针“虚”地指向它。无论继承链多复杂，大家都指向这同一个末尾。</p>
<p>既然虚继承有额外的内存和寻址开销，则使用时应该遵循以下原则：</p>
<ul>
<li><strong>不要滥用</strong>：只有当你确定会出现“菱形结构”且基类数据很大、必须唯一时才使用。</li>
<li><strong>架构设计</strong>：在设计大型插件系统或接口树（如 <code>iostream</code> 库中的 <code>ios</code> 基类）时，虚继承是处理多重职责合并的神器。</li>
</ul>
<h3 id="多层虚继承">多层虚继承</h3>
<p>如果现在我们创建了一个新类 <code>NewClass</code>，让它<strong>虚继承</strong>自 <code>Student</code> 和 <code>Teacher</code>（而这两者已经虚继承了 <code>Person</code>），这种情况被称为**“多层虚继承”**。</p>
<p>在这种情况下，会发生以下三件核心的事情：</p>
<h4 id="全局唯一性依然锁定">全局唯一性依然锁定</h4>
<p>无论你的继承链条有多深（A -&gt; B -&gt; C -&gt; D&hellip;），只要所有的继承路径都打上了 <code>virtual</code> 标签，那么在最终的对象（<code>NewClass</code>）内存里，<strong>顶层基类 <code>Person</code> 永远只有一份</strong>。</p>
<p>它不会因为 <code>Student</code> 和 <code>Teacher</code> 被再次虚继承而变成两份。编译器会像“收纳大师”一样，把最底层的 <code>Person</code> 踢到整个 <code>NewClass</code> 对象的<strong>最末尾</strong>，作为所有上层类共享的公共资源。</p>
<h4 id="内存布局的变化更多的地图">内存布局的变化：更多的“地图”</h4>
<p>当你让 <code>NewClass</code> 虚继承 <code>Student</code> 和 <code>Teacher</code> 时，<code>NewClass</code> 对象的内部结构会变得更加模块化：</p>
<p><strong>vbptr（虚基类指针）会增多</strong>：</p>
<ul>
<li><code>Student</code> 部分有一个 <code>vbptr</code>，用来找 <code>Person</code>。</li>
<li><code>Teacher</code> 部分有一个 <code>vbptr</code>，用来找 <code>Person</code>。</li>
<li><strong>新增：</strong> <code>NewClass</code> 也会拥有自己的 <code>vbptr</code>（或者复用现有的），用来在运行时寻找它的虚基类 <code>Student</code> 和 <code>Teacher</code>。</li>
</ul>
<p><strong>间接层增加</strong>： 现在，如果你想在 <code>NewClass</code> 中访问 <code>Person</code> 的数据，CPU 需要经过两次查找：</p>
<ol>
<li>查看 <code>NewClass</code> 的表，找到 <code>Student</code> 的位置。</li>
<li>查看 <code>Student</code> 的表，找到 <code>Person</code> 的位置。 （现代编译器通常会进行优化，将这些偏移量合并到一张大表里，实现“一步到位”，但逻辑上它是多层的。）</li>
</ol>
<h4 id="初始化责任的权力移交">初始化责任的“权力移交”</h4>
<p>这是 C++ 语法中最坑的一点，也是多层虚继承的必考点：<strong>初始化虚基类的责任，永远属于“最底层”的派生类。</strong></p>
<ul>
<li><strong>普通继承中</strong>：<code>NewClass</code> 负责初始化 <code>Student</code>，<code>Student</code> 负责初始化 <code>Person</code>。</li>
<li><strong>虚继承中</strong>：<code>Student</code> 和 <code>Teacher</code> 对 <code>Person</code> 的初始化调用在此时会被<strong>直接忽略</strong>！</li>
<li><strong>谁负责？</strong>：必须由 <strong><code>NewClass</code></strong> 的构造函数直接显式调用 <code>Person</code> 的构造函数。</li>
</ul>
<p>因为 <code>Person</code> 是共享的，如果由 <code>Student</code> 和 <code>Teacher</code> 分别去初始化，那 <code>Person</code> 到底听谁的？为了避免打架，C++ 规定：谁最后承载这个完整的对象，谁就负责最顶层虚基类的构造。</p>
<p>这种情况在工程中被称为 <strong>“虚继承格 (Virtual Inheritance Lattice)”</strong>。它的内存形状从简单的“菱形”变成了多层的“网格”：</p>
<pre class="mermaid">
  classDiagram
    class Person {
        唯一实例
        住在最底部
    }
    
    class Student {
    }
    
    class Teacher {
    }
    
    class NewClass {
        现在的掌权者
        负责管理所有的指针和偏移量
    }
    
    Person &lt;|-- Student : virtual
    Person &lt;|-- Teacher : virtual
    Student &lt;|-- NewClass : virtual
    Teacher &lt;|-- NewClass : virtual
    
    note for NewClass &#34;管理所有指针和偏移量&#34;
</pre>

<p><strong>唯一性</strong>：无论嵌套多少层，<code>virtual</code> 保证了最顶层的那个共享基类在内存里只有一份拷贝。</p>
<p><strong>指针开销</strong>：每一层虚继承都会引入额外的 <code>vbptr</code> 或增加 <code>vbtable</code> 的条目，这会让对象变“胖”，且访问成员变量的速度变慢（因为需要计算偏移）。</p>
<p><strong>构造权限</strong>：最底层的类（<code>NewClass</code>）夺取了对祖先类（<code>Person</code>）的初始化主权。</p>



  <blockquote class="dream-alert note">
    <p class="heading">
      <ion-icon name="information-circle-outline"></ion-icon>Note</p>
    <p><strong>为什么 C++ 程序员通常会尽量避免深层的多重虚继承?</strong></p>
<p>它虽然完美解决了数据冗余问题，但带来的内存布局复杂度和性能损耗就像“套娃”一样，层数越多，系统开销和理解成本就越高。</p>
  </blockquote>

<h2 id="动态多态-dynamic-polymorphism运行时的行为分发">动态多态 (Dynamic Polymorphism)：运行时的行为分发</h2>
<p><strong>多态</strong>是面向对象编程中最具魔力的部分，它允许你<strong>通过父类的指针或引用，去调用子类重写的方法</strong>。</p>
<p>C++ 的动态多态主要依赖于 <strong>虚函数 (Virtual Function)</strong> 机制。当一个类声明了虚函数，编译器会为该类生成一张<strong>虚函数表 (vtable)</strong>，表中存储了该类所有虚函数的实际入口地址。同时，每个该类的对象实例在内存的起始位置都会被秘密安插一个<strong>虚表指针 (vptr)</strong>，指向对应的虚函数表。</p>
<p>每个<strong>对象</strong>（在堆上或栈上）的内存起始位置，都会多出 8 字节（64位系统）来存放指向该类 <code>vtable</code> 的指针<code>vptr</code>。</p>
<p>当通过基类指针调用虚函数时，程序不再是简单的代码跳转，而是经历一次“间接寻址”：首先根据对象的 <code>vptr</code> 找到 <code>vtable</code>，再根据偏移量从表中提取正确的函数地址。这是实现多态的关键，但也带来了一定的运行时开销。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Shape</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">draw</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;画一个形状&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">Shape</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// 重要：虚析构函数防止内存泄漏
</span></span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Circle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">draw</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;画一个圆&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">render</span><span class="p">(</span><span class="n">Shape</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">();</span> <span class="c1">// 运行时决定调用哪个 draw
</span></span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当你调用 <code>s-&gt;draw()</code> 时，程序会：</p>
<ol>
<li>顺着指针 <code>s</code> 找到对象。</li>
<li>找到对象头部的 <code>vptr</code>。</li>
<li>通过 <code>vptr</code> 查 <code>vtable</code>。</li>
<li>跳到正确的函数地址执行。</li>
</ol>
<h3 id="为什么多态通常要配合堆对象和指针">为什么多态通常要配合堆对象和指针？</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">slice</span><span class="p">(</span><span class="n">Base</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="n">b</span><span class="p">.</span><span class="n">show</span><span class="p">();</span> <span class="p">}</span>    <span class="c1">// 值传递：发生“对象切片”
</span></span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">poly</span><span class="p">(</span><span class="n">Base</span><span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">();</span> <span class="p">}</span>   <span class="c1">// 指针传递：保留虚表指针
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>多态必须配合指针或引用使用</strong>，因为如果直接进行值传递（存放在栈上的普通对象赋值），会发生“对象切片 (Slicing)”现象——子类的特有数据和 <code>vptr</code> 会被丢弃，导致对象退化为基类，多态特性随之丧失。<strong>指针或引用</strong>只是一把“钥匙”，它能指向堆上更完整的子类对象，并能通过 <code>vptr</code> 找到正确的函数。</p>
<h3 id="虚析构函数的必要性">虚析构函数的必要性</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 接口（多态的基础）
</span></span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Tool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">work</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 纯虚函数
</span></span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">Tool</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 具体的零件（用于组合）
</span></span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Battery</span> <span class="p">{</span> <span class="k">public</span><span class="o">:</span> <span class="kt">int</span> <span class="n">power</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 具体的实现（继承自 Tool）
</span></span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Drill</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Tool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Battery</span> <span class="n">battery</span><span class="p">;</span> <span class="c1">// 【组合】：钻机有一个电池
</span></span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">work</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;钻头转动中...&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// 【多态重写】
</span></span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 使用
</span></span></span><span class="line"><span class="cl"><span class="n">Tool</span><span class="o">*</span> <span class="n">myTool</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Drill</span><span class="p">();</span> <span class="c1">// 多态调用
</span></span></span><span class="line"><span class="cl"><span class="n">myTool</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="k">delete</span> <span class="n">myTool</span><span class="p">;</span> <span class="c1">// 安全析构
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在多态体系中，<strong>虚析构函数</strong>是防止内存泄漏的最后一道防线。当一个类可能被继承且被多态使用时，必须将其<strong>析构函数</strong>声明为 <code>virtual</code>。这是因为，当我们通过基类指针 <code>delete</code> 一个派生类对象时，如果析构函数不是虚函数，编译器将执行“静态绑定”，仅调用基类的析构函数。</p>
<p>在这种情况下，派生类中特有的资源（如派生类在堆上申请的内存、打开的文件句柄等）将永远不会被释放。而一旦将基类析构函数设为 <code>virtual</code>，<code>delete</code> 操作就会通过虚函数表找到派生类的析构函数。派生类析构函数执行完毕后，会自动向上调用基类的析构函数，从而确保整个对象树的所有部分都能被完整、干净地清理。</p>
<h3 id="virtual关键字">virtual关键字</h3>
<p>在 C++ 之父 Bjarne Stroustrup 的设计哲学中，<code>virtual</code> 代表一种**“间接层”**。</p>
<ul>
<li><strong>虚函数</strong>是函数的间接化：你不直接调用函数，而是通过表去“查”函数。</li>
<li><strong>虚继承</strong>是数据的间接化：你不直接定位成员，而是通过表去“查”成员在内存里的偏移。</li>
</ul>
<p>计算机科学中有一句名言：</p>



  <blockquote>
    <p>&ldquo;Any problem in computer science can be solved with another layer of indirection.&rdquo;</p>
<p>(计算机科学中的任何问题都可以通过增加一个间接层来解决。)</p>

  </blockquote>

<p>在 C++ 中，<code>virtual</code> 这个关键字的本质含义是**“推迟到运行时再决定”**。虽然“虚函数”和“虚继承”共享同一个关键字，但它们推迟决定的内容完全不同：</p>
<ul>
<li><strong>虚函数</strong>推迟决定的是：<strong>“我要执行哪段代码？”</strong>（行为多态）</li>
<li><strong>虚继承</strong>推迟决定的是：<strong>“我的父类数据在哪？”</strong>（结构共享）</li>
</ul>
<p>虚函数 (Virtual Function) —— 解决“调用谁”</p>
<p>虚函数是为了实现<strong>动态多态</strong>。当你通过父类指针调用一个虚函数时，编译器在编译阶段并不知道你指向的是哪个子类。</p>
<p>虚函数的核心机制是vtable (虚函数表)，vtable中存放的是函数的内存地址。</p>
<p><strong>查找逻辑</strong>：<code>vptr</code> -&gt; <code>vtable</code> -&gt; <strong>跳转到对应的代码段 (Code Segment)</strong> 执行。</p>
<p>虚继承 (Virtual Inheritance) —— 解决“在哪找”</p>
<p>虚继承是为了解决<strong>菱形继承中的冗余</strong>。由于虚基类（如 <code>Person</code>）被多个路径共享，它在派生类（如 <code>TA</code>）的内存布局中位置是不固定的。</p>
<p>虚继承的核心机制是<strong>vbtable (虚基类表)</strong>，<code>vbtable</code> 中存放的是<strong>偏移量 (Offset)</strong>（即：从当前位置加/减多少字节能找到那个共享的基类）。</p>
<p><strong>查找逻辑</strong>：<code>vbptr</code> -&gt; <code>vbtable</code> -&gt; <strong>计算出数据在堆/栈中的内存偏移</strong> -&gt; 访问成员变量。</p>
<table>
  <thead>
      <tr>
          <th><strong>特性</strong></th>
          <th><strong>虚函数 (Virtual Function)</strong></th>
          <th><strong>虚继承 (Virtual Inheritance)</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>解决的问题</strong></td>
          <td>成员函数的<strong>多态调用</strong></td>
          <td>基类成员变量的<strong>存储冗余/二义性</strong></td>
      </tr>
      <tr>
          <td><strong>推迟的内容</strong></td>
          <td>函数的<strong>入口地址</strong></td>
          <td>基类子对象的<strong>内存偏移量</strong></td>
      </tr>
      <tr>
          <td><strong>引入的指针</strong></td>
          <td><code>vptr</code> (虚函数表指针)</td>
          <td><code>vbptr</code> (虚基类表指针)</td>
      </tr>
      <tr>
          <td><strong>指向的表</strong></td>
          <td><code>vtable</code> (存放函数指针)</td>
          <td><code>vbtable</code> (存放字节偏移值)</td>
      </tr>
      <tr>
          <td><strong>对大小的影响</strong></td>
          <td>增加一个指针大小</td>
          <td>增加一个或多个指针大小</td>
      </tr>
      <tr>
          <td><strong>性能损耗点</strong></td>
          <td>额外的函数跳转（间接调用）</td>
          <td>额外的地址计算（间接寻址）</td>
      </tr>
  </tbody>
</table>
<p>一个类可以既有虚函数，又被虚继承。在这种情况下，对象的内存布局会变得异常复杂：它可能既包含 <code>vptr</code>，又包含 <code>vbptr</code>。</p>



  <blockquote class="dream-alert tip">
    <p class="heading">
      <ion-icon name="bulb-outline"></ion-icon>Tip</p>
    <p><strong>现代编译器优化：</strong> 许多现代编译器（如 GCC/Clang 使用的 Itanium C++ ABI）为了节省空间，会把 <code>vbtable</code> 的功能合并进 <code>vtable</code> 中。也就是说，一个指针（vptr）可能既用来找虚函数，也用来找虚基类的偏移。但这不改变它们逻辑上的分离。</p>
  </blockquote>

<h3 id="vtable和vbtable存放在哪里">vtable和vbtable存放在哪里</h3>
<p>这些表（<code>vtable</code> 和 <code>vbtable</code>）既不在<strong>栈</strong>上，也不在<strong>堆</strong>上。它们存放于内存五个区域中的：<strong>只读数据段（Read-Only Data Segment）</strong>，在 Linux 系统底层通常被称为 <code>.rodata</code> 段。</p>
<p>在 C++ 程序运行时的内存布局中，<code>vtable</code> 和 <code>vbtable</code> 的位置如下：</p>
<p><strong>只读数据段 (.rodata)</strong>：存放 <strong>vtable</strong> 和 <strong>vbtable</strong>。</p>
<ul>
<li><strong>理由</strong>：这些表是由编译器在<strong>编译阶段</strong>生成的。由于一个类的所有对象共享同一份虚函数地址，且这些地址在程序运行期间不会改变，因此放在只读区既能节省空间（所有对象共用一份），又能防止被意外修改。</li>
</ul>
<p><strong>对象所在区（栈或堆）</strong>：存放 <strong>vptr</strong> 和 <strong>vbptr</strong>（即指向表的指针）。</p>
<ul>
<li>如果你在函数里写 <code>Circle c;</code>，<code>vptr</code> 就在<strong>栈</strong>上。</li>
<li>如果你写 <code>Shape* s = new Circle();</code>，<code>vptr</code> 就在<strong>堆</strong>上的对象头部。</li>
</ul>
<p><strong>代码段 (.text)</strong>：存放虚函数本身的<strong>机器指令</strong>。</p>
<ul>
<li><code>vtable</code> 里的条目只是指向这些指令起始位置的“门牌号”。</li>
</ul>
<table>
  <thead>
      <tr>
          <th><strong>内存区域</strong></th>
          <th><strong>存放内容</strong></th>
          <th><strong>生命周期</strong></th>
          <th><strong>管理方式</strong></th>
          <th><strong>包含的 OOP 元素</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>栈 (Stack)</strong></td>
          <td>局部变量、函数参数</td>
          <td>函数结束即销毁</td>
          <td>系统自动</td>
          <td>栈对象、<code>vptr</code> 指针、<code>vbptr</code> 指针</td>
      </tr>
      <tr>
          <td><strong>堆 (Heap)</strong></td>
          <td><code>new</code> 出来的对象</td>
          <td>随 <code>delete</code> 销毁</td>
          <td>程序员手动</td>
          <td>堆对象及其内部的 <code>vptr</code></td>
      </tr>
      <tr>
          <td><strong>全局/静态存储区</strong></td>
          <td>全局变量、<code>static</code> 变量</td>
          <td>程序结束销毁</td>
          <td>系统自动</td>
          <td>单例对象、静态成员变量</td>
      </tr>
      <tr>
          <td><strong>只读数据区 (.rodata)</strong></td>
          <td>常量、字符串字面量</td>
          <td>永久</td>
          <td>系统自动</td>
          <td><strong>vtable (虚表)</strong>、<strong>vbtable (虚基类表)</strong></td>
      </tr>
      <tr>
          <td><strong>代码区 (.text)</strong></td>
          <td>函数二进制指令</td>
          <td>永久</td>
          <td>系统自动</td>
          <td>成员函数、静态函数、虚函数代码</td>
      </tr>
  </tbody>
</table>
<h3 id="多重继承下的多指针">多重继承下的多指针</h3>
<p>上面的结论提到一个继承了虚函数对象有一个 <code>vptr</code>，但实际上在<strong>多重继承</strong>中，这个结论是错的。</p>
<p>假设你有两个独立的基类，它们都有自己的虚函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Base1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func1</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Base1::func1&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">data1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Base2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func2</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Base2::func2&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">data2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 派生类同时继承两者
</span></span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base1</span><span class="p">,</span> <span class="k">public</span> <span class="n">Base2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">func1</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Derived::func1&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">func2</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Derived::func2&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">data3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>此时会出现一个矛盾点：</p>
<p>当你把 <code>Derived*</code> 转成 <code>Base1*</code> 时，代码期望在指针开头看到 <code>Base1</code> 的虚表。</p>
<p>当你把 <code>Derived*</code> 转成 <code>Base2*</code> 时，代码期望在指针开头看到 <code>Base2</code> 的虚表。</p>
<p>如果只有一个 <code>vptr</code>，它只能指向一张表。那么 <code>Base2</code> 路径的调用就会彻底乱套，因为它会在 <code>Base1</code> 的表里寻找 <code>func2</code>。</p>
<p>为了解决这个问题，编译器将 <code>Derived</code> 对象拆分成了多个“基类子对象”。在 64 位系统下，<code>Derived</code> 的内存长相大约是这样的：</p>
<table>
  <thead>
      <tr>
          <th><strong>偏移量</strong></th>
          <th><strong>内容</strong></th>
          <th><strong>说明</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>0 - 7</strong></td>
          <td><strong>vptr1</strong></td>
          <td>指向 <code>Derived</code> 的第一张虚表（包含 Base1 和 Derived 自己的函数）</td>
      </tr>
      <tr>
          <td><strong>8 - 11</strong></td>
          <td><strong>data1</strong></td>
          <td>Base1 的成员变量</td>
      </tr>
      <tr>
          <td><strong>12 - 15</strong></td>
          <td><em>(Padding)</em></td>
          <td>内存对齐</td>
      </tr>
      <tr>
          <td><strong>16 - 23</strong></td>
          <td><strong>vptr2</strong></td>
          <td>指向 <code>Derived</code> 的第二张虚表（专门负责 Base2 路径的跳转）</td>
      </tr>
      <tr>
          <td><strong>24 - 27</strong></td>
          <td><strong>data2</strong></td>
          <td>Base2 的成员变量</td>
      </tr>
      <tr>
          <td><strong>28 - 31</strong></td>
          <td><strong>data3</strong></td>
          <td>Derived 自己的成员变量</td>
      </tr>
  </tbody>
</table>
<p>一个 <code>Derived</code> 对象里有两个虚表指针。如果你再继承一个 <code>Base3</code>，就会有第三个。</p>
<p>当你进行指针类型转换时，<strong>指针的数值实际上发生了改变</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Derived</span><span class="o">*</span> <span class="n">d</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Derived</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">Base1</span><span class="o">*</span> <span class="n">b1</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>            <span class="c1">// b1 的地址和 d 是一样的（指向对象开头）
</span></span></span><span class="line"><span class="cl"><span class="n">Base2</span><span class="o">*</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>            <span class="c1">// 重点：b2 的地址比 d 增加了 16 字节！
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>b1</strong> 指向对象的起始位置。那里刚好是 <code>vptr1</code>，符合 <code>Base1</code> 的预期。</p>
<p><strong>b2</strong> 被编译器自动“挪”到了后面 16 字节处。那里刚好是 <code>vptr2</code>，符合 <code>Base2</code> 的预期。</p>
<p>这种自动调整地址的技术，确保了无论你把对象看作哪个父类，它都能在其“视角”的起始位置找到正确的虚表。</p>
<p>这里还有一个深层问题： 当通过 <code>Base2*</code> 调用 <code>func2</code> 时，执行的是 <code>Derived::func2</code>。但 <code>Derived::func2</code> 内部可能需要访问 <code>data1</code>（对象的开头）。 可是此时的 <code>this</code> 指针指向的是 <code>Base2</code> 的子对象（偏移了 16 字节的地方）。</p>
<p><strong>编译器如何解决？</strong> 虚表里存的不仅仅是函数地址，有时是一段被称为 <strong>“thunk”</strong> 的简短机器码。</p>
<ul>
<li>当调用通过 <code>vptr2</code> 发生时，程序先跳到 thunk。</li>
<li><strong>thunk 做一件事</strong>：把 <code>this</code> 指针减去 16，使其重新指向 <code>Derived</code> 对象的开头。</li>
<li>然后再跳转到真正的 <code>Derived::func2</code>。</li>
</ul>
<hr>
<h3 id="基础概念补充">基础概念补充</h3>
<h4 id="纯虚函数pure-virtual-function">纯虚函数(Pure Virtual Function)</h4>
<p>纯虚函数是一种特殊的虚函数，它在基类中<strong>没有定义（没有实现）</strong>，要求派生类必须自行实现。</p>
<p><strong>语法</strong>：在虚函数声明后面加上 <code>= 0</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Shape</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 纯虚函数：我不知道怎么画一个“形状”，但我要求子类必须会画
</span></span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">draw</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">Shape</span><span class="p">()</span> <span class="p">{}</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在虚函数表（vtable）中，纯虚函数对应的位置通常存放的是一个**空指针（nullptr）**或者指向一个名为 <code>__pure_virtual_called</code> 的错误处理函数。这保证了程序在运行时如果不小心调用了它，会直接报错而不是乱跳地址。</p>
<h4 id="抽象类abstract-class">抽象类(Abstract Class)</h4>
<p>只要一个类中包含<strong>至少一个</strong>纯虚函数，这个类就自动成为了<strong>抽象类</strong>。抽象类是类的“半成品”，不能独立存在（不能 new），必须被继承。</p>



  <blockquote class="dream-alert caution">
    <p class="heading">
      <ion-icon name="alert-circle-outline"></ion-icon>Caution</p>
    <p>抽象类<strong>不能实例化对象</strong>。</p>
<p><code>Shape s;</code> // <strong>错误！</strong> 编译器会报错，因为 Shape 是抽象的。</p>
<p><code>Shape* s = new Circle();</code> // <strong>正确！</strong> 你可以拥有指向抽象类的指针或引用。</p>
  </blockquote>

<p>它纯粹是为了给子类提供一个共同的“模版”或“基石”。</p>
<h4 id="接口-interface">接口 (Interface)</h4>
<p>在 Java 或 C# 中有 <code>interface</code> 关键字，但在 C++ 中，接口是通过<strong>特殊的抽象类</strong>来实现的。接口是最高级的抽象，它不代表“是什么”，只代表“能做什么”。</p>
<p><strong>一个 C++ 接口通常满足以下条件</strong>：</p>
<ol>
<li>没有任何成员变量（Data Members）。</li>
<li>所有的成员函数都是<strong>纯虚函数</strong>（Pure Virtual）。</li>
<li>有一个虚析构函数。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 这是一个“可飞行”的接口
</span></span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">IFlyable</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">takeOff</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">land</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">IFlyable</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 这是一个“可游泳”的接口
</span></span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ISwimmable</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">swim</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">ISwimmable</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 具体的类：鸭子（既能飞又能游）
</span></span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Duck</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IFlyable</span><span class="p">,</span> <span class="k">public</span> <span class="n">ISwimmable</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">takeOff</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">land</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">swim</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>结合之前的多重继承的指针之谜，你会发现接口在 C++ 中非常强大：</p>
<p><strong>解耦</strong>：你的函数可以只接收 <code>IFlyable*</code>，而不需要知道这个对象到底是“飞机”还是“鸭子”。</p>
<p><strong>安全性</strong>：通过接口，你只暴露了对象的一部分能力。比如你把 <code>Duck</code> 对象传给一个只接受 <code>ISwimmable*</code> 的函数，那个函数就只能让鸭子游泳，而不能让它起飞。</p>
<p><strong>内存布局</strong>：当你使用多个接口时，编译器会自动为每个接口生成一个 <code>vptr</code>。这保证了当你把 <code>Duck*</code> 转换成 <code>IFlyable*</code> 时，指针会自动偏移到对应的虚表位置。</p>


        
      </section>

      

      
    </article>
  </div>

  <div
    x-data="tocHighlighter()"
    @scroll.window="debouncedScroll"
    class="hidden lg:flex lg:flex-col lg:items-end lg:self-start"
  >
    
  </div>
</div>


            
<footer class="flex justify-between items-center gap-2 px-4 py-12">

  <div>
  
  <p>
    © 2021 - 2026 古月月仔的博客
  </p>
  

  
  <p class="text-sm">
    🌱
    <span class="text-base-content/60">
      Powered by <a class="hover:underline" href="https://gohugo.io/" target="_blank">Hugo</a> with theme
      <a class="hover:underline" href="https://github.com/g1eny0ung/hugo-theme-dream" target="_blank">Dream</a>.</span
    >
  </p>
  
</div>

  <div
  x-data="{ icons: [
    { name: 'sunny', status: 'n' },
    { name: 'moon', status: 'y' },
    { name: 'desktop', status: 'auto' }
  ] }"
  class="flex items-center gap-2 h-[32px] px-2 bg-base-100 border border-base-content/30 rounded-full"
>
  <template x-for="icon in icons">
    <div
      role="button"
      tabindex="0"
      :aria-label="'Select ' + icon.name + ' mode'"
      class="group inline-flex justify-center items-center p-1 rounded-full cursor-pointer hover:bg-primary"
      :class="$store.darkMode.icon() === icon.name && 'bg-primary'"
      @click="$store.darkMode.toggle(icon.status)"
    >
      <ion-icon
        :name="`${icon.name}-outline`"
        class="group-hover:text-primary-content"
        :class="$store.darkMode.icon() === icon.name && 'text-primary-content'"
      >
      </ion-icon>
    </div>
  </template>
</div>

</footer>

          </div>
        </div>
        <div class="back">
          <div class="container">
            
            <div class="dream-grid dream-grid-about">
  
  
  
  <div class="w-full md:w-1/2 lg:w-1/3 xl:w-1/4 p-4 dream-column">
    <article
      class="card bg-base-100 hover:bg-base-content/10 shadow-xl dark:border dark:border-base-content/30"
    >
      <div class="card-body">
        <div class="card-title">关于我</div>

        <div class="prose dark:prose-invert">
          <ul>
<li>我是<strong>古月月仔</strong></li>
<li><strong>Ethan Hu</strong></li>
<li>分享技术学习笔记与生活点滴</li>
<li><strong>现居</strong>： 上海 中国</li>
<li><strong>家乡</strong>： 平遥 山西</li>
</ul>

        </div>
      </div>
    </article>
  </div>
  
  <div class="w-full md:w-1/2 lg:w-1/3 xl:w-1/4 p-4 dream-column">
    <article
      class="card bg-base-100 hover:bg-base-content/10 shadow-xl dark:border dark:border-base-content/30"
    >
      <div class="card-body">
        <div class="card-title">在用的学习工具</div>

        <div class="prose dark:prose-invert">
          <ul>
<li>📝 <a href="https://typora.io/" target="_blank">Typora</a>
 —— 极致简洁的 Markdown 编辑器，助力沉浸式文档撰写与知识记录。</li>
<li>📓 <a href="https://www.notion.so/" target="_blank">Notion</a>
 —— 一站式工作空间，用于搭建个人知识库、项目管理与深度协作。</li>
<li>🔗 <a href="https://n8n.io/" target="_blank">N8N</a>
 —— 强大的基于节点的自动化工作流工具，轻松实现不同应用间的逻辑联动。</li>
<li>🤖 <a href="https://gemini.google.com/" target="_blank">Gemini</a>
 —— 智能 AI 助手，在代码辅助、创意激发与信息检索中提供强力支撑。</li>
</ul>

        </div>
      </div>
    </article>
  </div>
  
  <div class="w-full md:w-1/2 lg:w-1/3 xl:w-1/4 p-4 dream-column">
    <article
      class="card bg-base-100 hover:bg-base-content/10 shadow-xl dark:border dark:border-base-content/30"
    >
      <div class="card-body">
        <div class="card-title">我的爱好</div>

        <div class="prose dark:prose-invert">
          <ul>
<li>🚀 喜欢折腾各种好玩的技术</li>
<li>📸 业余摄影爱好者</li>
<li>🎮 各类游戏玩家</li>
<li>💻 数码产品折腾爱好者</li>
<li>📚 阅读：赫尔曼·黑塞 &amp; 阿尔贝·加缪</li>
<li>🎞️ 追番中：《电锯人：蕾塞篇》</li>
<li>🎬 经典重温：《命运石之门》</li>
</ul>

        </div>
      </div>
    </article>
  </div>
  
  <div class="w-full md:w-1/2 lg:w-1/3 xl:w-1/4 p-4 dream-column">
    <article
      class="card bg-base-100 hover:bg-base-content/10 shadow-xl dark:border dark:border-base-content/30"
    >
      <div class="card-body">
        <div class="card-title">最近正在学</div>

        <div class="prose dark:prose-invert">
          <ul>
<li>🎨 <a href="https://games104.boomingtech.com/" target="_blank">GAMES104</a>
 —— 现代游戏引擎入门。</li>
<li>🏔️ <a href="https://www.sidefx.com/learn/" target="_blank">Houdini 基础</a>
 —— 学习程序化建模与特效。</li>
<li>🤗 <a href="https://huggingface.co/learn" target="_blank">Hugging Face</a>
 —— 探索开源 AI 社区。</li>
</ul>

        </div>
      </div>
    </article>
  </div>
  
  

  

  
</div>

            

            
<footer class="flex justify-between items-center gap-2 px-4 py-12">

  <div>
  
  <p>
    © 2021 - 2026 古月月仔的博客
  </p>
  

  
  <p class="text-sm">
    🌱
    <span class="text-base-content/60">
      Powered by <a class="hover:underline" href="https://gohugo.io/" target="_blank">Hugo</a> with theme
      <a class="hover:underline" href="https://github.com/g1eny0ung/hugo-theme-dream" target="_blank">Dream</a>.</span
    >
  </p>
  
</div>

  <div
  x-data="{ icons: [
    { name: 'sunny', status: 'n' },
    { name: 'moon', status: 'y' },
    { name: 'desktop', status: 'auto' }
  ] }"
  class="flex items-center gap-2 h-[32px] px-2 bg-base-100 border border-base-content/30 rounded-full"
>
  <template x-for="icon in icons">
    <div
      role="button"
      tabindex="0"
      :aria-label="'Select ' + icon.name + ' mode'"
      class="group inline-flex justify-center items-center p-1 rounded-full cursor-pointer hover:bg-primary"
      :class="$store.darkMode.icon() === icon.name && 'bg-primary'"
      @click="$store.darkMode.toggle(icon.status)"
    >
      <ion-icon
        :name="`${icon.name}-outline`"
        class="group-hover:text-primary-content"
        :class="$store.darkMode.icon() === icon.name && 'text-primary-content'"
      >
      </ion-icon>
    </div>
  </template>
</div>

</footer>

          </div>
        </div>
      </div>
    </div>

    <script>
  window.lightTheme = "emerald"
  window.darkTheme = "forest"
</script>


  <script src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js"></script>

  
  
  <script src="/js/grid.js"></script>




<script src="/js/main.js"></script>
    







<script src="/js/toc.js"></script>




  




    
      <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.4.1/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true });
      </script>
    

    
      <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [
        ['\\[', '\\]'],
        ['$$', '$$'],
      ], 
      inlineMath: [
        ['\\(', '\\)'],
        ['$', '$'],
      ], 
    },
  }
</script>

    

    

    

    <script type="module" src="https://cdn.jsdelivr.net/npm/ionicons@7.4.0/dist/ionicons/ionicons.esm.js" integrity="sha256-/IFmi82bIhdYWctu0UddSlJqpnzWm7Vh2C4CM32wF/k=" crossorigin="anonymous"></script>
    <script nomodule src="https://cdn.jsdelivr.net/npm/ionicons@7.4.0/dist/ionicons/ionicons.js" integrity="sha256-mr7eJMX3VC3F7G32mk4oWp1C6a2tlMYxUdptfT7uKI8=" crossorigin="anonymous"></script>
  </body>
</html>
