<!DOCTYPE html>
<html lang="zh-cn"
  x-data
  :class="$store.darkMode.class()"
  :data-theme="$store.darkMode.theme()">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>【Games101】几何表达与绘制 | 古月月仔的博客</title>

    

<link rel="canonical" href="http://localhost:1313/posts/games101%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/" />


<meta name="author" content="古月月仔" />
<meta name="description" content="几何是计算机图形学三维建模与渲染的基础，应用于物体建模、几何变换和碰撞检测。其表示方法主要分为隐式表示（如代数曲面、水平集）和显式表示（如点云），用于描述不同复杂度的形状。" />
<meta name="keywords" content="图形学,GAMES课程,几何,几何表示,Geometry,Blend">


<meta name="generator" content="Hugo 0.153.1">

<meta property="og:url" content="http://localhost:1313/posts/games101%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/">
  <meta property="og:site_name" content="古月月仔的博客">
  <meta property="og:title" content="【Games101】几何表达与绘制">
  <meta property="og:description" content="几何是计算机图形学三维建模与渲染的基础，应用于物体建模、几何变换和碰撞检测。其表示方法主要分为隐式表示（如代数曲面、水平集）和显式表示（如点云），用于描述不同复杂度的形状。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-07-05T00:00:00+08:00">
    <meta property="article:modified_time" content="2025-07-05T00:00:00+08:00">
    <meta property="article:tag" content="图形学">
    <meta property="article:tag" content="GAMES课程">
    <meta property="article:tag" content="几何">
    <meta property="article:tag" content="几何表示">
    <meta property="article:tag" content="Geometry">
    <meta property="article:tag" content="Blend">



  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="【Games101】几何表达与绘制">
  <meta name="twitter:description" content="几何是计算机图形学三维建模与渲染的基础，应用于物体建模、几何变换和碰撞检测。其表示方法主要分为隐式表示（如代数曲面、水平集）和显式表示（如点云），用于描述不同复杂度的形状。">




<link rel="stylesheet" href="/css/output.css" />



<script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3/dist/cdn.min.js"></script>
<link rel="stylesheet" href="/css/custom.css">
<script src="/js/code_block.js" defer></script>

    


<style>
  pre {
    padding: 1em;
    overflow: auto;
  }
</style>









    

    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3/dist/cdn.min.js" integrity="sha256-4EHxtjnR5rL8JzbY12OKQJr81ESm7JBEb49ORPo29AY=" crossorigin="anonymous"></script>
  </head>
<script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js"></script>

<style>
   
  .medium-zoom-overlay {
    z-index: 100;
    background: rgba(0, 0, 0, 0.8) !important;
  }
  .medium-zoom-image--opened {
    z-index: 101;
  }
</style>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    
    const zoom = mediumZoom('.zoomable', {
      margin: 24,          
      background: '#000',  
      scrollOffset: 40,    
    });
  });
</script>
  <body x-data="{
    flip: false,
  }">
    
    <div id="dream-global-bg"></div>

    
<nav class="mt-4 lg:mt-8 py-4">

  
  <div class="container flex justify-between px-4">
  
    <section class="flex items-center gap-4">
      <div class="avatar cursor-pointer hover:avatar-online" @click="flip = !flip" title="Flip it!">
        <div class="h-10 rounded-full">
          <img src="/img/ChipDog.jpg" alt="古月月仔的博客" />
        </div>
      </div>

      
      <div>
        
        <a href="http://localhost:1313/" class="text-lg font-semibold cursor-pointer">
          古月月仔的博客
        </a>
        
        
        <div class="text-base-content/60 text-sm">计算机在校生 || 游戏程序员
记录从基础到进阶的每一份思考。</div>
        
      </div>
      
    </section>

    
    

    <div class="dropdown dropdown-end sm:hidden">
      <div tabindex="0" role="button" class="btn btn-ghost btn-square" aria-label="Select an option">
        <ion-icon name="menu" class="text-2xl"></ion-icon>
      </div>
      <ul tabindex="0" class="dropdown-content menu w-36 bg-base-100 rounded-box z-1 shadow-md">
        







<li>
  <div role="link" tabindex="0" class="inline-flex items-center p-2 cursor-pointer" @click="flip = !flip" title="About">
    <ion-icon name="information-circle"></ion-icon>About</div>
</li>





















<li>
  <a class="inline-flex items-center p-2 cursor-pointer" href="/posts" title="Archives">
    <ion-icon name="archive"></ion-icon>
    Archives
  </a>
</li>




<li>
  <a class="inline-flex items-center p-2 cursor-pointer" href="/categories" title="All Categories">
    <ion-icon name="grid"></ion-icon>
    All Categories
  </a>
</li>




<li>
  <a class="inline-flex items-center p-2 cursor-pointer" href="/tags" title="All Tags">
    <ion-icon name="pricetags"></ion-icon>
    All Tags
  </a>
</li>






      </ul>
    </div>
    <section class="hidden sm:flex sm:items-center sm:gap-2 md:gap-4">
      

      
      




<div role="link" tabindex="0" class="text-sm font-semibold cursor-pointer hover:underline" @click="flip = !flip" title="About">About</div>





      
      





      
      





      
      
<a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary" href="/posts" title="Archives">
  <ion-icon class="group-hover:text-primary-content" name="archive"></ion-icon>
</a>


      
      
<a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary" href="/categories" title="All Categories">
  <ion-icon class="group-hover:text-primary-content" name="grid"></ion-icon>
</a>


      
      
<a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary" href="/tags" title="All Tags">
  <ion-icon class="group-hover:text-primary-content" name="pricetags"></ion-icon>
</a>


      

      

      
    </section>
  </div>
</nav>


    <div class="flip-container" :class="{ 'flip-it': flip }">
      <div class="flipper">
        <div class="front">
          <div class="container">
            
<div class="lg:grid lg:grid-cols-4 gap-4 mt-4 px-4">
  <div class="hidden lg:block">
    
  </div>

  <div class="lg:col-span-2">
    <article class="mx-auto prose prose-quoteless dark:prose-invert" id="dream-single-post-main" itemscope itemtype="http://schema.org/Article">
      
  <meta itemprop="name" content="【Games101】几何表达与绘制">
  <meta itemprop="description" content="几何是计算机图形学三维建模与渲染的基础，应用于物体建模、几何变换和碰撞检测。其表示方法主要分为隐式表示（如代数曲面、水平集）和显式表示（如点云），用于描述不同复杂度的形状。">
  <meta itemprop="datePublished" content="2025-07-05T00:00:00+08:00">
  <meta itemprop="dateModified" content="2025-07-05T00:00:00+08:00">
  <meta itemprop="wordCount" content="667">
  <meta itemprop="keywords" content="图形学,GAMES课程,几何,几何表示,Geometry,Blend">

      <header>
        <h1 itemprop="headline">【Games101】几何表达与绘制</h1>
        <p class="text-sm">
          
            Saturday, Jul 5, 2025
          

          | <span>4 minute read</span>

          
          | <span>Updated at
            
              Saturday, Jul 5, 2025
            </span>
          
        </p>

        
        <div class="flex justify-between">
          
            <div class="flex items-center">
  
  <span>@</span>
  

  <span itemprop="author" itemscope itemtype="https://schema.org/Person">
  
    <span itemprop="name">古月月仔</span>
  
  </span>
</div>

          

          <div class="flex items-center gap-2">
  
  

  
  
  
  
  
    <a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary"
      href="https://x.com/intent/post?text=%e3%80%90Games101%e3%80%91%e5%87%a0%e4%bd%95%e8%a1%a8%e8%be%be%e4%b8%8e%e7%bb%98%e5%88%b6&amp;url=http://localhost:1313/posts/games101%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/" target="_blank" rel="noopener noreferrer"
      title="Share on X">
      <ion-icon class="group-hover:text-primary-content" name="logo-x"></ion-icon>
    </a>
  
    <a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary"
      href="https://facebook.com/sharer/sharer.php?u=http://localhost:1313/posts/games101%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/" target="_blank" rel="noopener noreferrer"
      title="Share on Facebook">
      <ion-icon class="group-hover:text-primary-content" name="logo-facebook"></ion-icon>
    </a>
  
    <a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary"
      href="https://wa.me/?text=%e3%80%90Games101%e3%80%91%e5%87%a0%e4%bd%95%e8%a1%a8%e8%be%be%e4%b8%8e%e7%bb%98%e5%88%b6%20http://localhost:1313/posts/games101%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/" target="_blank" rel="noopener noreferrer"
      title="Share on WhatsApp">
      <ion-icon class="group-hover:text-primary-content" name="logo-whatsapp"></ion-icon>
    </a>
  

  
  
</div>

        </div>
      </header>

      <section id="dream-single-post-content" itemprop="articleBody">
        

        <p>几何是计算机图形学中三维建模与渲染的基础，应用于物体建模、几何变换和碰撞检测等领域。其表示方法主要分为隐式表示（如代数曲面、水平集和距离函数）和显式表示，用于描述不同复杂度的形状。</p>
<h1 id="几何概念">几何概念</h1>



  <blockquote class="dream-alert tip">
    <p class="heading">
      <ion-icon name="bulb-outline"></ion-icon>Tip</p>
    <p>个人感觉本章前面的内容有点空洞和理论，建议直接快速浏览，从几何处理部分看起。</p>
  </blockquote>

<h2 id="几何的应用applications-of-geometry">几何的应用（Applications of Geometry）</h2>
<p>在图形学中，几何不仅仅关乎抽象的数学对象，它是三维建模和渲染的基础。以下是几何学的几个应用领域：</p>
<p><strong>物体建模</strong>：通过几何学，计算机可以表示任何形状，例如从简单的几何体（如球体、立方体等）到复杂的自由形状（如汽车、人物模型等）。</p>
<p><strong>几何变换</strong>：在渲染和动画中，物体的形状需要根据不同的需要进行变换，例如平移、旋转、缩放等。这些变换都可以通过几何学的运算来实现。</p>
<p><strong>碰撞检测</strong>：几何学还用于物理引擎中的碰撞检测，确保虚拟世界中的物体不会穿透或重叠。</p>
<p><figure style="text-align: center; margin: 1.5rem auto;">
  
  <img src="http://localhost:1313/posts/games101%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/2025-07-05-%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/image-20251203140412366.png" 
       alt="image-20251203140412366" 
       
       class="zoomable" 
       style="max-width: 100%; height: auto; border-radius: 8px; cursor: zoom-in;"
       loading="lazy" />
  
    <figcaption style="margin-top: 8px; font-size: 0.85em; color: #888; font-style: italic;">
      image-20251203140412366
    </figcaption>
  
</figure></p>
<h2 id="几何表示representations-of-geometry">几何表示（Representations of Geometry)</h2>
<h3 id="隐式表示implicit-representations">隐式表示（Implicit Representations）</h3>
<p>隐式表示并不是直接通过列举点或多边形来描述物体的表面，而是通过某个数学方程或函数来定义物体的几何形状。隐式表示方法通过一个方程或函数来表示物体表面上的所有点。这些函数通常被用来定义物体的边界或表面。</p>
<p><strong>代数曲面（Algebraic Surfaces）</strong></p>
<p><figure style="text-align: center; margin: 1.5rem auto;">
  
  <img src="http://localhost:1313/posts/games101%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/2025-07-05-%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/image-20251203140426016.png" 
       alt="image-20251203140426016" 
       
       class="zoomable" 
       style="max-width: 100%; height: auto; border-radius: 8px; cursor: zoom-in;"
       loading="lazy" />
  
    <figcaption style="margin-top: 8px; font-size: 0.85em; color: #888; font-style: italic;">
      image-20251203140426016
    </figcaption>
  
</figure></p>
<p>代数曲面是通过代数方程来描述物体的形状。最简单的例子是球体，它可以通过方程 $x^2 + y^2 + z^2 = r^2$ 来表示。这种表示方法非常直观，适合表示对称性较好的几何形状，但对于复杂图形无能为力。</p>
<p><strong>水平集（Level Sets）</strong></p>
<p><figure style="text-align: center; margin: 1.5rem auto;">
  
  <img src="http://localhost:1313/posts/games101%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/2025-07-05-%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/image-20251203140443215.png" 
       alt="image-20251203140443215" 
       
       class="zoomable" 
       style="max-width: 100%; height: auto; border-radius: 8px; cursor: zoom-in;"
       loading="lazy" />
  
    <figcaption style="margin-top: 8px; font-size: 0.85em; color: #888; font-style: italic;">
      image-20251203140443215
    </figcaption>
  
</figure></p>
<p>水平集是一种使用数学函数来表示几何物体的方式。具体来说，水平集方法使用一个标量场（scalar field） $f(x, y, z)$ 来表示物体的形状。物体的表面是通过找到函数值为0的点来确定的。例如，球体可以表示为函数 $f(x, y, z) = x^2 + y^2 + z^2 - r^2$ 的零水平面。</p>
<p>水平集方法常用于模拟流体、气体、柔体物体等，其优点是能够自然地表示拓扑变化（如合并或分裂），非常适合动态模拟。</p>
<p><strong>距离函数（Distance Functions）</strong></p>
<p><figure style="text-align: center; margin: 1.5rem auto;">
  
  <img src="http://localhost:1313/posts/games101%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/2025-07-05-%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/image-20251203140450659.png" 
       alt="image-20251203140450659" 
       
       class="zoomable" 
       style="max-width: 100%; height: auto; border-radius: 8px; cursor: zoom-in;"
       loading="lazy" />
  
    <figcaption style="margin-top: 8px; font-size: 0.85em; color: #888; font-style: italic;">
      image-20251203140450659
    </figcaption>
  
</figure></p>
<ul>
<li>距离函数表示物体表面的每一点到物体表面最近点的距离。对于球体，距离函数是 $d(x, y, z) = \sqrt{x^2 + y^2 + z^2} - r$，其中 $r$ 是球体的半径。</li>
<li>距离函数配合插值可以通过简单的数学操作实现物体的融合等变换。</li>
</ul>
<h3 id="显式几何表示explicit-representations">显式几何表示（Explicit Representations）</h3>
<p>显式表示方法是通过直接列出物体的几何表面上的点、边或面来表示物体。显式表示通常使用网格或曲面来表示物体的表面，适用于大多数静态几何形状和计算机图形学中的渲染。常见的显性表示方法有：</p>
<p><strong>点云（Point Cloud）</strong></p>
<p><figure style="text-align: center; margin: 1.5rem auto;">
  
  <img src="http://localhost:1313/posts/games101%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/2025-07-05-%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/image-20251203140500066.png" 
       alt="image-20251203140500066" 
       
       class="zoomable" 
       style="max-width: 100%; height: auto; border-radius: 8px; cursor: zoom-in;"
       loading="lazy" />
  
    <figcaption style="margin-top: 8px; font-size: 0.85em; color: #888; font-style: italic;">
      image-20251203140500066
    </figcaption>
  
</figure></p>
<p>点云表示物体的表面通过一组离散的点来表示。每个点有自己的三维坐标，所有这些点共同描述了物体的形状。点云通常用于通过3D扫描（如激光扫描）获取的实际物体模型，或者在某些特定的计算机视觉应用中（如表面重建）。</p>
<p><strong>多边形网格（Polygon Mesh）</strong></p>
<p><figure style="text-align: center; margin: 1.5rem auto;">
  
  <img src="http://localhost:1313/posts/games101%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/2025-07-05-%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/image-20251203140508951.png" 
       alt="image-20251203140508951" 
       
       class="zoomable" 
       style="max-width: 100%; height: auto; border-radius: 8px; cursor: zoom-in;"
       loading="lazy" />
  
    <figcaption style="margin-top: 8px; font-size: 0.85em; color: #888; font-style: italic;">
      image-20251203140508951
    </figcaption>
  
</figure></p>
<p>多边形网格是最常见的几何表示方法，它通过一组连接在一起的多边形（通常是三角形或四边形）来表示物体的表面。每个多边形由顶点、边和面组成。多边形网格可以非常灵活地表示复杂的几何形状，广泛应用于3D建模、动画和游戏中。多边形网格的顶点通常通过顶点坐标、法线、纹理坐标等属性来描述。</p>
<p><strong>细分曲面（Subdivision Surfaces）</strong></p>
<p><figure style="text-align: center; margin: 1.5rem auto;">
  
  <img src="http://localhost:1313/posts/games101%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/2025-07-05-%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/image-20251203140516399.png" 
       alt="image-20251203140516399" 
       
       class="zoomable" 
       style="max-width: 100%; height: auto; border-radius: 8px; cursor: zoom-in;"
       loading="lazy" />
  
    <figcaption style="margin-top: 8px; font-size: 0.85em; color: #888; font-style: italic;">
      image-20251203140516399
    </figcaption>
  
</figure></p>
<p>细分曲面是一种基于细分方法生成平滑曲面的技术。它从一个较为粗糙的多边形网格开始，通过递归细分每个面（例如四边形或三角形）来生成更加光滑的曲面。细分曲面技术被广泛用于需要光滑曲面建模的领域，例如汽车外形、人物建模等。典型的细分曲面算法有Catmull-Clark细分和Doo-Sabin细分。</p>
<p><strong>NURBS（非均匀有理B样条，Non-Uniform Rational B-Splines）</strong></p>
<p>NURBS是一种基于样条曲线和曲面的表示方法，它允许非常精确地描述曲线和曲面。通过NURBS，可以表示出既平滑又准确的复杂几何形状。NURBS广泛应用于工业设计、建筑设计等领域，尤其适合表示复杂的自由曲面。</p>
<h2 id="bezier-曲线bézier-curves">Bezier 曲线（Bézier Curves）</h2>
<p>在计算机图形学中，Bezier 曲线是非常重要的工具，广泛应用于字体设计、动画插值、路径绘制等领域</p>
<p><figure style="text-align: center; margin: 1.5rem auto;">
  
  <img src="http://localhost:1313/posts/games101%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/2025-07-05-%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/image-20251203140523433.png" 
       alt="image-20251203140523433" 
       
       class="zoomable" 
       style="max-width: 100%; height: auto; border-radius: 8px; cursor: zoom-in;"
       loading="lazy" />
  
    <figcaption style="margin-top: 8px; font-size: 0.85em; color: #888; font-style: italic;">
      image-20251203140523433
    </figcaption>
  
</figure></p>
<p>三次 Bézier 曲线由 <strong>4 个控制点</strong>定义，分别为：</p>
<ul>
<li>$p_0$ 起点</li>
<li>$p_1$ 起点处的控制点，决定曲线的初始切线方向</li>
<li>$p_2$ 终点处的控制点，决定曲线的结束切线方向</li>
<li>$p_3$ 终点</li>
</ul>
<p><figure style="text-align: center; margin: 1.5rem auto;">
  
  <img src="http://localhost:1313/posts/games101%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/2025-07-05-%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/image-20251203140530353.png" 
       alt="image-20251203140530353" 
       
       class="zoomable" 
       style="max-width: 100%; height: auto; border-radius: 8px; cursor: zoom-in;"
       loading="lazy" />
  
    <figcaption style="margin-top: 8px; font-size: 0.85em; color: #888; font-style: italic;">
      image-20251203140530353
    </figcaption>
  
</figure></p>
<p>这四个点共同决定了曲线的形状。Bezier 曲线的一个显著特性是，曲线始终在由这些控制点构成的凸包内部，这保证了曲线的形状可控。</p>
<p><strong>de Casteljau 算法：计算 Bézier 曲线</strong></p>
<p><figure style="text-align: center; margin: 1.5rem auto;">
  
  <img src="http://localhost:1313/posts/games101%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/2025-07-05-%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/image-20251203140537375.png" 
       alt="image-20251203140537375" 
       
       class="zoomable" 
       style="max-width: 100%; height: auto; border-radius: 8px; cursor: zoom-in;"
       loading="lazy" />
  
    <figcaption style="margin-top: 8px; font-size: 0.85em; color: #888; font-style: italic;">
      image-20251203140537375
    </figcaption>
  
</figure></p>
<p><strong>de Casteljau 算法</strong>是一种递归方法，用于计算任意阶数的 Bézier 曲线。该算法使用 <strong>线性插值</strong>（lerp）不断地缩小控制点的范围，直到找到曲线的精确位置。对于二次 Bézier 曲线（3 个点）而言，计算过程如下：</p>
<ul>
<li>首先在 $b_0$ 和 $b_1$ 之间做线性插值，得到点 $b^0_1$</li>
<li>接着在 $b_1$ 和 $b_2$ 之间做线性插值，得到点 $b^1_1$</li>
<li>最后对这两个点 $b^0_1$ 和 $b^1_1$ 做线性插值，得到最终的曲线点 $b^0_2$</li>
</ul>
<p>对于三次 Bézier 曲线（4 个点），则递归地将每两个控制点进行插值，最终通过四层递归计算得到曲线上的点。</p>
<p><figure style="text-align: center; margin: 1.5rem auto;">
  
  <img src="http://localhost:1313/posts/games101%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/2025-07-05-%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/image-20251203140545928.png" 
       alt="image-20251203140545928" 
       
       class="zoomable" 
       style="max-width: 100%; height: auto; border-radius: 8px; cursor: zoom-in;"
       loading="lazy" />
  
    <figcaption style="margin-top: 8px; font-size: 0.85em; color: #888; font-style: italic;">
      image-20251203140545928
    </figcaption>
  
</figure></p>
<p>这一方法直观且稳定，适用于计算机图形学中对曲线的实时渲染。</p>
<p><strong>Bézier 曲线的代数表达式</strong></p>
<p>除了使用 de Casteljau 算法外，Bézier 曲线还可以通过 <strong>代数公式</strong>进行表示。对于三次 Bézier 曲线，其代数形式为：
</p>
$$
b(t) = (1-t)^3 b_0 + 3t(1-t)^2 b_1 + 3t^2(1-t) b_2 + t^3 b_3
$$<p>
该公式中的每一项使用了 <strong>Bernstein 多项式</strong>，其中 $B_i^3(t)$ 是基函数。Bernstein 多项式的性质使得 Bézier 曲线在 $t = 0$ 和 $t = 1$ 处分别插值起点和终点，并且控制点的数目决定了曲线的阶数。</p>
<p><strong>Bézier 曲线的重要性质</strong></p>
<p>Bézier 曲线有几个重要的几何性质，这些特性使得它在图形学中非常有用：</p>
<p><figure style="text-align: center; margin: 1.5rem auto;">
  
  <img src="http://localhost:1313/posts/games101%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/2025-07-05-%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/image-20251203140552902.png" 
       alt="image-20251203140552902" 
       
       class="zoomable" 
       style="max-width: 100%; height: auto; border-radius: 8px; cursor: zoom-in;"
       loading="lazy" />
  
    <figcaption style="margin-top: 8px; font-size: 0.85em; color: #888; font-style: italic;">
      image-20251203140552902
    </figcaption>
  
</figure></p>
<ul>
<li><strong>插值端点</strong>：曲线一定通过起点和终点，保证了其起始和结束位置的精确性。</li>
<li><strong>端点处切线方向</strong>：三次 Bézier 曲线的切线方向由起点到第一个控制点的向量决定，从而提供了端点处的方向性。</li>
<li><strong>仿射不变性</strong>：对控制点进行平移、旋转或缩放变换时，曲线形状保持不变，只会随控制点的变换而变。</li>
<li><strong>凸包性质</strong>：曲线始终位于其控制点构成的凸包内，这一点保证了曲线不会脱离设计范围。</li>
</ul>
<p>这些特性使得 Bézier 曲线非常适合用于路径设计和动画控制。</p>
<p><strong>分段 Bézier 曲线（Piecewise Bézier Curves）</strong></p>
<p><figure style="text-align: center; margin: 1.5rem auto;">
  
  <img src="http://localhost:1313/posts/games101%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/2025-07-05-%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/image-20251203140559687.png" 
       alt="image-20251203140559687" 
       
       class="zoomable" 
       style="max-width: 100%; height: auto; border-radius: 8px; cursor: zoom-in;"
       loading="lazy" />
  
    <figcaption style="margin-top: 8px; font-size: 0.85em; color: #888; font-style: italic;">
      image-20251203140559687
    </figcaption>
  
</figure></p>
<p><a href="https://math.hws.edu/eck/cs424/notes2013/canvas/bezier.html" target="_blank">Bezier Curve Edit</a>
</p>
<p>由于高阶 Bézier 曲线（控制点超过 4 个）难以控制和调整，实际应用中通常采用 <strong>分段 Bézier 曲线</strong>。将多条低阶 Bézier 曲线拼接起来，可以实现复杂的曲线形状，同时保持每段曲线的平滑性和可控性。</p>
<p>例如，在字体设计中，字形曲线通常是通过多个三次 Bézier 曲线连接形成的。为了保证连接处的平滑性，分段 Bézier 曲线通常要求满足 <strong>C⁰ 连续性</strong>（位置连续）和 <strong>C¹ 连续性</strong>（切线连续），即连接处的曲线要在位置和切线方向上无缝衔接。</p>
<p>分段 Bézier 曲线的广泛应用使其成为图形设计中非常重要的工具。</p>
<h3 id="双三次-bézier-曲面片段">双三次 Bézier 曲面片段</h3>
<p><strong>Bicubic Bézier Surface Patch双三次 Bézier 曲面片段</strong>是 Bézier 曲线扩展到曲面上的应用，它是 3D 图形学中用于表示平滑曲面的一种方法。这个部分是计算机图形学中的高级内容，通常用于描述复杂的曲面。</p>
<p><figure style="text-align: center; margin: 1.5rem auto;">
  
  <img src="http://localhost:1313/posts/games101%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/2025-07-05-%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/image-20251203140605684.png" 
       alt="image-20251203140605684" 
       
       class="zoomable" 
       style="max-width: 100%; height: auto; border-radius: 8px; cursor: zoom-in;"
       loading="lazy" />
  
    <figcaption style="margin-top: 8px; font-size: 0.85em; color: #888; font-style: italic;">
      image-20251203140605684
    </figcaption>
  
</figure></p>
<p>Bicubic Bézier 曲面是通过 <strong>4×4 个控制点</strong>来定义的，类似于一条三次 Bézier 曲线通过 4 个控制点来定义，但这里是二维的曲面，而非一维曲线。每个控制点是一个 3D 点，具有 x, y, z 坐标。通过这些控制点，可以描述一个曲面。</p>
<p>这个曲面的参数化是通过两个变量 $u$ 和 $v$ 来进行的，分别表示曲面上点的位置：</p>
<ul>
<li>$u$ 表示在 <strong>横向方向</strong>（从左到右）上的变化</li>
<li>$v$ 表示在 <strong>纵向方向</strong>（从上到下）上的变化</li>
</ul>
<p>这两个参数都在区间 [0, 1] 之间变化。</p>
<p>Bicubic Bézier 曲面定义需要 <strong>16 个控制点</strong>，这些控制点组织成一个 <strong>4×4 的控制点网格</strong>。在这个网格中，每个点 $P_{ij}$ 的位置是一个三维坐标点 $P_{ij} = (x_{ij}, y_{ij}, z_{ij})$，其中 $i$ 和 $j$ 分别表示横向和纵向的索引。</p>
<p><figure style="text-align: center; margin: 1.5rem auto;">
  
  <img src="http://localhost:1313/posts/games101%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/2025-07-05-%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/image-20251203140611158.png" 
       alt="image-20251203140611158" 
       
       class="zoomable" 
       style="max-width: 100%; height: auto; border-radius: 8px; cursor: zoom-in;"
       loading="lazy" />
  
    <figcaption style="margin-top: 8px; font-size: 0.85em; color: #888; font-style: italic;">
      image-20251203140611158
    </figcaption>
  
</figure></p>
<p><strong>计算 Bicubic Bézier 曲面上的点</strong></p>
<p>为了计算曲面上某个位置的点，我们需要确定两个参数 $u$ 和 $v$ 对应的曲面位置。这个计算通过在两个方向上分别应用 <strong>de Casteljau 算法</strong> 来完成，最终得到一个表面上的点。</p>
<p><strong>步骤一：沿着 $u$ 方向插值</strong></p>
<p>首先，沿着 $u$ 方向对每一行的 4 个控制点进行线性插值（de Casteljau 算法），得到 4 个新的曲线，这些曲线表示了在 $v$ 固定时，沿 $u$ 方向的变化。</p>
<p>假设 $u$ 为给定的参数值，那么对于每一行控制点 $P_{i0}, P_{i1}, P_{i2}, P_{i3}$，我们可以按照 de Casteljau 算法计算出新的插值控制点 $Q_i(t)$，即：
</p>
$$
Q_0 = (1 - u)P_{00} + uP_{01}
$$<p>
<strong>步骤二：沿着 $v$ 方向插值</strong></p>
<p>然后，沿着 $v$ 方向对刚才得到的 4 个插值点 $Q_0, Q_1, Q_2, Q_3$ 进行再次插值，得到最终曲面上的点 $P(u, v)$：
</p>
$$
P(u, v) = (1 - v)Q_0 + vQ_1
$$<p>
通过这个过程，我们可以计算出任意 $u$ 和 $v$ 对应的曲面上的点。最终，$P(u, v)$ 就是位于给定参数值 $u$ 和 $v$ 的曲面上的点。</p>
<h1 id="几何处理geometry-processing">几何处理Geometry Processing</h1>
<p><strong>Mesh Operations: Geometry Processing</strong>（网格操作：几何处理）是计算机图形学中的一个重要概念，涉及对3D模型网格的各种操作。网格是由顶点、边和面构成的结构，在图形学中，网格用于表示3D物体的表面。<strong>几何处理</strong>则指的是一系列操作，用于改变或优化网格的形状、质量或性能，以满足不同应用的需求。</p>
<h2 id="网格细分mesh-subdivision">网格细分（Mesh Subdivision）</h2>
<p>网格细分是将粗糙的网格进行更精细的分割，目的是使得网格表面更加平滑。这个过程通常通过将每个面进一步细分为更多的小面来完成。细分操作的典型例子有 <strong>Catmull-Clark细分</strong> 和 <strong>Loop细分</strong>，它们都能产生更光滑、更高细节的网格。</p>
<p><figure style="text-align: center; margin: 1.5rem auto;">
  
  <img src="http://localhost:1313/posts/games101%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/2025-07-05-%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/image-20251130000407988.png" 
       alt="image-20251130000407988" 
       
       class="zoomable" 
       style="max-width: 100%; height: auto; border-radius: 8px; cursor: zoom-in;"
       loading="lazy" />
  
    <figcaption style="margin-top: 8px; font-size: 0.85em; color: #888; font-style: italic;">
      image-20251130000407988
    </figcaption>
  
</figure></p>
<h3 id="loop-subdivision">Loop Subdivision</h3>
<p><strong>Loop 细分</strong>是一种用于 <strong>三角网格</strong> 的细分算法，它的基本思想是将每个三角形面分割成四个更小的三角形，并调整顶点的位置，使得网格表面更加平滑。</p>
<p><figure style="text-align: center; margin: 1.5rem auto;">
  
  <img src="http://localhost:1313/posts/games101%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/2025-07-05-%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/image-20251130000429482.png" 
       alt="image-20251130000429482" 
       
       class="zoomable" 
       style="max-width: 100%; height: auto; border-radius: 8px; cursor: zoom-in;"
       loading="lazy" />
  
    <figcaption style="margin-top: 8px; font-size: 0.85em; color: #888; font-style: italic;">
      image-20251130000429482
    </figcaption>
  
</figure></p>
<p><strong>Loop 细分步骤</strong></p>
<ul>
<li><strong>步骤 1：细分三角形</strong>
每一个三角形都会被分割成四个更小的三角形。在原网格的每一个三角形中，算法会插入一个新的顶点，将每个三角形分割成四个小三角形。这些新顶点的位置是通过对原有三角形的顶点进行加权计算得到的。</li>
</ul>
<p><figure style="text-align: center; margin: 1.5rem auto;">
  
  <img src="http://localhost:1313/posts/games101%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/2025-07-05-%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/image-20251130000522716.png" 
       alt="image-20251130000522716" 
       
       class="zoomable" 
       style="max-width: 100%; height: auto; border-radius: 8px; cursor: zoom-in;"
       loading="lazy" />
  
    <figcaption style="margin-top: 8px; font-size: 0.85em; color: #888; font-style: italic;">
      image-20251130000522716
    </figcaption>
  
</figure></p>
<ul>
<li><strong>步骤 2：更新顶点位置</strong>
更新新顶点的位置时，原始顶点和新顶点的位置是通过不同的加权系数来计算的。新顶点的更新通常基于周围邻域的顶点的加权平均位置。</li>
</ul>
<p><figure style="text-align: center; margin: 1.5rem auto;">
  
  <img src="http://localhost:1313/posts/games101%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/2025-07-05-%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/image-20251130000553759.png" 
       alt="image-20251130000553759" 
       
       class="zoomable" 
       style="max-width: 100%; height: auto; border-radius: 8px; cursor: zoom-in;"
       loading="lazy" />
  
    <figcaption style="margin-top: 8px; font-size: 0.85em; color: #888; font-style: italic;">
      image-20251130000553759
    </figcaption>
  
</figure></p>
<p>例如，对于三角形的一个新顶点的计算，Loop 细分使用以下方式：
</p>
$$
\text{新顶点位置} = \frac{3}{8} \times (A + B) + \frac{1}{8} \times (C + D)
$$<p>
其中 $A, B, C, D$ 是原始三角形的顶点。</p>
<ul>
<li><strong>步骤 3：处理旧顶点</strong>
对于原来的顶点（即，三角形的顶点），它们也会被更新。更新方法考虑了该顶点与相邻顶点的关系，通常使用以下公式：</li>
</ul>
$$
\text{更新顶点位置} = (1 - n \times u) \times \text{原位置} + u \times \text{邻域顶点位置总和}
$$<p><figure style="text-align: center; margin: 1.5rem auto;">
  
  <img src="http://localhost:1313/posts/games101%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/2025-07-05-%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/image-20251130000619475.png" 
       alt="image-20251130000619475" 
       
       class="zoomable" 
       style="max-width: 100%; height: auto; border-radius: 8px; cursor: zoom-in;"
       loading="lazy" />
  
    <figcaption style="margin-top: 8px; font-size: 0.85em; color: #888; font-style: italic;">
      image-20251130000619475
    </figcaption>
  
</figure></p>
<p>其中，$n$ 是顶点的度数（邻居数量），$u$ 是一个权重因子，决定了更新位置的偏移程度。</p>
<p>通过不断重复这些步骤，网格逐渐变得更加光滑和精细。Loop 细分常用于 <strong>三角网格</strong>，特别是需要高分辨率且平滑表面的场景。</p>



  <blockquote class="dream-alert tip">
    <p class="heading">
      <ion-icon name="bulb-outline"></ion-icon>Tip</p>
    <p>Loop Subdivision方法的Loop和循环没有关系，是因为科学家的家人姓Loop。(●&rsquo;◡&rsquo;●)</p>
  </blockquote>

<h3 id="catmull-clark-subdivision">Catmull-Clark Subdivision</h3>
<p><strong>Catmull-Clark 细分</strong>是一种 <strong>面向四边形网格的细分算法</strong>，但它同样可以处理 <strong>非四边形网格</strong>。当一个网格中的某些顶点的度数不为四（即顶点的连接边数不等于四时），这些顶点被称为 <strong>奇异点</strong>（<strong>Extraordinary vertices</strong>）。</p>
<p><strong>奇异点的定义</strong></p>
<p>在 Catmull-Clark 细分中，<strong>奇异点</strong>指的是 <strong>度数不等于四的顶点</strong>。例如，一个顶点可能与三条边相连（度数为3），或者与五条边相连（度数为5），这些顶点就被视为奇异点。</p>
<ul>
<li>对于常规的 <strong>非奇异顶点</strong>（度数为4的顶点），细分时会按照标准的更新规则进行更新。</li>
<li>而对于 <strong>奇异点</strong>，细分时需要采取特殊的处理方法。</li>
</ul>
<p><strong>奇异点的处理</strong></p>
<p>在 Catmull-Clark 细分过程中，奇异点的更新需要特别注意。由于奇异点的度数不为四，它的 <strong>位置更新规则</strong> 与普通顶点有所不同。为保证细分后的网格仍然平滑，并且能够处理多边形面，Catmull-Clark 细分算法在细分过程中会特别处理这些奇异点。</p>
<p>具体来说，<strong>奇异点</strong>的更新通常依赖于该点的 <strong>邻域结构</strong>（即连接该点的面和顶点的布局）。在更新过程中，算法会利用该点周围的邻域信息来计算它的新位置。</p>
<p><strong>算法步骤</strong></p>
<p><figure style="text-align: center; margin: 1.5rem auto;">
  
  <img src="http://localhost:1313/posts/games101%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/2025-07-05-%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/%E5%9B%BE%E7%89%876.png" 
       alt="图片6" 
       
       class="zoomable" 
       style="max-width: 100%; height: auto; border-radius: 8px; cursor: zoom-in;"
       loading="lazy" />
  
    <figcaption style="margin-top: 8px; font-size: 0.85em; color: #888; font-style: italic;">
      图片6
    </figcaption>
  
</figure></p>
<ol>
<li>
<p><strong>每个面（面片）添加新顶点</strong>：
在每个面（如四边形面或非四边形面）中，添加一个新的 <strong>面顶点</strong>。面顶点的位置是通过当前面上四个顶点的加权平均来计算的：
</p>
$$
   \text{面顶点位置} = \frac{v_1 + v_2 + v_3 + v_4}{4}
   $$<p>
其中 $v_1, v_2, v_3, v_4$ 是面上的四个顶点。</p>
</li>
<li>
<p><strong>每条边添加新顶点</strong>：
每条边的中点位置也是新的顶点。这个 <strong>边顶点</strong> 是通过计算当前边的两个端点和相邻面顶点的加权平均来得到的。公式如下：
</p>
$$
   \text{边顶点位置} = \frac{v_1 + v_2 + f_1 + f_2}{4}
   $$<p>
其中 $v_1, v_2$ 是边的两个端点，$f_1, f_2$ 是与该边相邻的两个面的面顶点。</p>
</li>
<li>
<p><strong>每个顶点更新位置</strong>：
对于原网格中的每个顶点，更新其位置。这些原始顶点的位置更新不仅仅取决于它们自己的位置，还依赖于它们周围邻域的顶点。更新公式如下：
</p>
$$
   \text{更新顶点位置} = \frac{f_1 + f_2 + f_3 + f_4 + 2(m_1 + m_2 + m_3 + m_4) + 4p}{16}
   $$<p>
其中：</p>
<ul>
<li>$f_1, f_2, f_3, f_4$ 是与顶点相邻的四个面顶点。</li>
<li>$m_1, m_2, m_3, m_4$ 是与该顶点相邻的四个边顶点。</li>
<li>$p$ 是原顶点的原始位置。</li>
</ul>
</li>
</ol>
<p>通过这些步骤，Catmull-Clark 细分能够使网格更加平滑，同时保持原始几何形状的轮廓。</p>
<h3 id="细分的收敛性与形状"><strong>细分的收敛性与形状</strong></h3>
<p>细分算法的 <strong>收敛性</strong> 指的是经过多次细分后，网格最终趋向于某种平滑形状的能力。不同的细分算法在处理带有 <strong>锐角</strong> 或 <strong>硬边（creases）</strong> 的形状时表现不同。</p>
<ul>
<li><strong>Loop 细分</strong> 在带有锐角或硬边的地方可能会导致不够精细的处理。</li>
<li><strong>Catmull-Clark 细分</strong> 对于带有硬边的形状能更好地保持这些特征，通常在处理复杂形状时效果更好。</li>
</ul>
<p><figure style="text-align: center; margin: 1.5rem auto;">
  
  <img src="http://localhost:1313/posts/games101%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/2025-07-05-%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/image-20251130005346760.png" 
       alt="image-20251130005346760" 
       
       class="zoomable" 
       style="max-width: 100%; height: auto; border-radius: 8px; cursor: zoom-in;"
       loading="lazy" />
  
    <figcaption style="margin-top: 8px; font-size: 0.85em; color: #888; font-style: italic;">
      image-20251130005346760
    </figcaption>
  
</figure></p>
<h2 id="网格简化mesh-simplification">网格简化（Mesh Simplification）</h2>
<p><strong>Mesh Simplification 的目标</strong></p>
<p>网格简化的目标是 <strong>减少网格的分辨率</strong>，即减少顶点、边和面数，目的是：</p>
<ul>
<li><strong>提高渲染性能</strong>：降低网格的复杂性，使得渲染过程更加高效。</li>
<li><strong>保持形状和外观</strong>：在简化过程中，尽量保持网格原有的形状和外观，使得简化后的模型与原模型相似。</li>
</ul>
<p>具体来说，简化过程中会通过优化顶点和面片的数目来减少计算量，同时 <strong>避免过多失真</strong>，确保简化后的网格仍能准确地表示物体的主要特征。</p>
<p><figure style="text-align: center; margin: 1.5rem auto;">
  
  <img src="http://localhost:1313/posts/games101%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/2025-07-05-%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/image-20251130012222427.png" 
       alt="image-20251130012222427" 
       
       class="zoomable" 
       style="max-width: 100%; height: auto; border-radius: 8px; cursor: zoom-in;"
       loading="lazy" />
  
    <figcaption style="margin-top: 8px; font-size: 0.85em; color: #888; font-style: italic;">
      image-20251130012222427
    </figcaption>
  
</figure></p>



  <blockquote class="dream-alert tip">
    <p class="heading">
      <ion-icon name="bulb-outline"></ion-icon>Tip</p>
    <p>如果网格简化效果不好，那就让美工回去重建嘻嘻(●&rsquo;◡&rsquo;●)</p>
  </blockquote>

<h3 id="边坍缩edge-collapse"><strong>边坍缩（Edge Collapse）</strong></h3>
<p><figure style="text-align: center; margin: 1.5rem auto;">
  
  <img src="http://localhost:1313/posts/games101%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/2025-07-05-%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/image-20251130012344155.png" 
       alt="image-20251130012344155" 
       
       class="zoomable" 
       style="max-width: 100%; height: auto; border-radius: 8px; cursor: zoom-in;"
       loading="lazy" />
  
    <figcaption style="margin-top: 8px; font-size: 0.85em; color: #888; font-style: italic;">
      image-20251130012344155
    </figcaption>
  
</figure></p>
<p>最常见的网格简化方法之一是 <strong>边坍缩</strong>，也叫做 <strong>边合并</strong>。该方法的基本思想是 <strong>合并相邻的边和顶点</strong>，通过这种方式，简化网格中的面片数量。</p>
<ul>
<li><strong>步骤</strong>：选择一条边，将该边的两个端点合并为一个新顶点，原来的面片被更新或删除，从而减少了网格的复杂度。</li>
<li><strong>效果</strong>：每次合并一条边可以减少两个顶点和一条边，从而减少了面片数。通过重复这一操作，可以显著降低网格的面数和顶点数。</li>
</ul>
<p>在进行边折叠时，通常需要计算 <strong>几何误差</strong>，以确保合并后的新顶点不会引起形状失真。</p>
<p><figure style="text-align: center; margin: 1.5rem auto;">
  
  <img src="http://localhost:1313/posts/games101%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/2025-07-05-%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/image-20251130012406528.png" 
       alt="image-20251130012406528" 
       
       class="zoomable" 
       style="max-width: 100%; height: auto; border-radius: 8px; cursor: zoom-in;"
       loading="lazy" />
  
    <figcaption style="margin-top: 8px; font-size: 0.85em; color: #888; font-style: italic;">
      image-20251130012406528
    </figcaption>
  
</figure></p>
<p><strong>如何计算几何误差</strong>？</p>
<p>为了确保网格简化后保持良好的形状，通常会使用 <strong>几何误差度量</strong>。几何误差是指合并顶点时，简化后的顶点与原始位置之间的差异。常见的误差度量包括：</p>
<ul>
<li><strong>二次误差（Quadric Error Metric）</strong>：一种常用的误差度量方法，它衡量的是合并顶点后与原始三角形面之间的距离。通过这种方法，可以评估每次顶点合并时引入的误差大小，从而选择合适的边进行合并。
<ul>
<li><strong>原理</strong>：每次简化时，通过计算新顶点到原三角形的距离，尽量选择那些对几何形状影响最小的边进行折叠。</li>
</ul>
</li>
<li><strong>边折叠误差</strong>：在合并每一条边时，选择使误差最小化的顶点进行合并。</li>
</ul>



  <blockquote class="dream-alert tip">
    <p class="heading">
      <ion-icon name="bulb-outline"></ion-icon>Tip</p>
    <p>这里的基于二次误差去不断尝试去规划到底坍缩哪一条边，有点类似于深度学习中的以梯度下降损失函数收敛为目标的训练步骤</p>
  </blockquote>

<p><figure style="text-align: center; margin: 1.5rem auto;">
  
  <img src="http://localhost:1313/posts/games101%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/2025-07-05-%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/image-20251130012447069.png" 
       alt="image-20251130012447069" 
       
       class="zoomable" 
       style="max-width: 100%; height: auto; border-radius: 8px; cursor: zoom-in;"
       loading="lazy" />
  
    <figcaption style="margin-top: 8px; font-size: 0.85em; color: #888; font-style: italic;">
      image-20251130012447069
    </figcaption>
  
</figure></p>
<p>在网格简化后，网格的复杂性会显著降低，渲染速度提高，但简化的程度取决于具体应用的需求。例如，在某些游戏场景中，较低分辨率的网格可以大大提升渲染效率，尤其是在需要实时渲染的情况下。简化后的网格可以通过 <strong>不断迭代折叠边缘</strong> 来逐渐达到目标面数，同时最大限度地保留物体的形状细节。</p>
<p>如上图所示，边坍缩以后的牛牛还是尽量保持了原有的形态特征的。</p>
<h2 id="网格正则化mesh-regularization">网格正则化（Mesh Regularization）</h2>
<p><strong>网格正则化（Mesh Regularization）</strong> 是计算机图形学中用于改善网格质量的一个重要技术，特别是在网格优化和几何处理时。它的目标是 <strong>调整网格中顶点的分布</strong>，以达到 <strong>更均匀的网格分布</strong>，进而优化后续的处理过程，如渲染、模拟等。正则化的核心是通过改变顶点的布局或位置，使得网格的质量更加平衡，从而提高网格的稳定性和准确性。</p>
<p><figure style="text-align: center; margin: 1.5rem auto;">
  
  <img src="http://localhost:1313/posts/games101%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/2025-07-05-%E5%87%A0%E4%BD%95%E8%A1%A8%E8%BE%BE%E4%B8%8E%E7%BB%98%E5%88%B6/image-20251130013042023.png" 
       alt="image-20251130013042023" 
       
       class="zoomable" 
       style="max-width: 100%; height: auto; border-radius: 8px; cursor: zoom-in;"
       loading="lazy" />
  
    <figcaption style="margin-top: 8px; font-size: 0.85em; color: #888; font-style: italic;">
      image-20251130013042023
    </figcaption>
  
</figure></p>
<p>网格正则化通常有以下几种常见操作：</p>
<p><strong>顶点重新定位（Vertex Relocation）</strong></p>
<p>这一方法通过 <strong>移动顶点的位置</strong>，使得顶点分布更加均匀。通常，优化方法会基于网格的局部几何结构来决定每个顶点的新位置，使得网格面片的形状更加规整。</p>
<ul>
<li><strong>目标</strong>：使得每个面片（例如三角形或四边形）的大小、形状相对均匀，避免出现极长或极小的三角形/四边形。</li>
<li><strong>方法</strong>：计算每个顶点的“拉力”或“压力”，然后调整顶点位置，通常是根据其邻域顶点的布局和网格局部的变化来决定。</li>
</ul>
<p><strong>拉普拉斯平滑（Laplacian Smoothing）</strong></p>
<p><strong>拉普拉斯平滑</strong>是一种常见的网格正则化技术，它通过计算每个顶点与其邻域顶点的 <strong>平均位置</strong> 来平滑网格。</p>
<ul>
<li><strong>原理</strong>：每个顶点的位置将被调整为该顶点邻接顶点的位置的加权平均。</li>
<li><strong>步骤</strong>：将顶点位置与邻域顶点的平均位置进行对比，调整顶点位置，使得局部网格更加平滑。</li>
<li><strong>效果</strong>：减少网格中突兀的角落或尖锐的区域，使网格更加均匀和平滑。</li>
</ul>
<p><strong>网格均匀化（Mesh Uniformization）</strong></p>
<p>网格均匀化技术的目标是通过调整顶点的位置，使得网格的 <strong>顶点分布更加均匀</strong>，尤其是在曲面或复杂形状的情况下。这通常涉及将顶点重新分布，使得 <strong>每个面</strong> 的大小大致相同，避免某些区域的顶点过于稠密或稀疏。</p>
<ul>
<li><strong>方法</strong>：可以使用迭代优化算法，基于目标函数（如顶点分布的均匀性）进行优化。</li>
<li><strong>目标</strong>：使得网格的各个部分在分辨率上保持一致，以避免出现 <strong>不规则的变形</strong> 或 <strong>局部失真</strong>。</li>
</ul>
<p><strong>局部平滑（Local Smoothing）</strong></p>
<p>局部平滑是一种针对特定网格区域的正则化操作，它通过对网格的一部分（例如某个面片或某些顶点）进行平滑，改善局部几何结构。</p>
<ul>
<li><strong>方法</strong>：只对选定区域内的顶点进行平滑，而不影响整个网格。常用于处理网格中局部结构不平衡的情况。</li>
<li><strong>效果</strong>：改善局部区域的质量，同时保持全局形状不变。</li>
</ul>


        
      </section>

      

      
    </article>
  </div>

  <div
    x-data="tocHighlighter()"
    @scroll.window="debouncedScroll"
    class="hidden lg:flex lg:flex-col lg:items-end lg:self-start"
  >
    
  </div>
</div>


            
<footer class="flex justify-between items-center gap-2 px-4 py-12">

  <div>
  
  <p>
    © 2021 - 2026 古月月仔的博客
  </p>
  

  
  <p class="text-sm">
    🌱
    <span class="text-base-content/60">
      Powered by <a class="hover:underline" href="https://gohugo.io/" target="_blank">Hugo</a> with theme
      <a class="hover:underline" href="https://github.com/g1eny0ung/hugo-theme-dream" target="_blank">Dream</a>.</span
    >
  </p>
  
</div>

  <div
  x-data="{ icons: [
    { name: 'sunny', status: 'n' },
    { name: 'moon', status: 'y' },
    { name: 'desktop', status: 'auto' }
  ] }"
  class="flex items-center gap-2 h-[32px] px-2 bg-base-100 border border-base-content/30 rounded-full"
>
  <template x-for="icon in icons">
    <div
      role="button"
      tabindex="0"
      :aria-label="'Select ' + icon.name + ' mode'"
      class="group inline-flex justify-center items-center p-1 rounded-full cursor-pointer hover:bg-primary"
      :class="$store.darkMode.icon() === icon.name && 'bg-primary'"
      @click="$store.darkMode.toggle(icon.status)"
    >
      <ion-icon
        :name="`${icon.name}-outline`"
        class="group-hover:text-primary-content"
        :class="$store.darkMode.icon() === icon.name && 'text-primary-content'"
      >
      </ion-icon>
    </div>
  </template>
</div>

</footer>

          </div>
        </div>
        <div class="back">
          <div class="container">
            
            <div class="dream-grid dream-grid-about">
  
  
  
  <div class="w-full md:w-1/2 lg:w-1/3 xl:w-1/4 p-4 dream-column">
    <article
      class="card bg-base-100 hover:bg-base-content/10 shadow-xl dark:border dark:border-base-content/30"
    >
      <div class="card-body">
        <div class="card-title">关于我</div>

        <div class="prose dark:prose-invert">
          <ul>
<li>我是<strong>古月月仔</strong></li>
<li><strong>Ethan Hu</strong></li>
<li>分享技术学习笔记与生活点滴</li>
<li><strong>现居</strong>： 上海 中国</li>
<li><strong>家乡</strong>： 平遥 山西</li>
</ul>

        </div>
      </div>
    </article>
  </div>
  
  <div class="w-full md:w-1/2 lg:w-1/3 xl:w-1/4 p-4 dream-column">
    <article
      class="card bg-base-100 hover:bg-base-content/10 shadow-xl dark:border dark:border-base-content/30"
    >
      <div class="card-body">
        <div class="card-title">在用的学习工具</div>

        <div class="prose dark:prose-invert">
          <ul>
<li>📝 <a href="https://typora.io/" target="_blank">Typora</a>
 —— 极致简洁的 Markdown 编辑器，助力沉浸式文档撰写与知识记录。</li>
<li>📓 <a href="https://www.notion.so/" target="_blank">Notion</a>
 —— 一站式工作空间，用于搭建个人知识库、项目管理与深度协作。</li>
<li>🔗 <a href="https://n8n.io/" target="_blank">N8N</a>
 —— 强大的基于节点的自动化工作流工具，轻松实现不同应用间的逻辑联动。</li>
<li>🤖 <a href="https://gemini.google.com/" target="_blank">Gemini</a>
 —— 智能 AI 助手，在代码辅助、创意激发与信息检索中提供强力支撑。</li>
</ul>

        </div>
      </div>
    </article>
  </div>
  
  <div class="w-full md:w-1/2 lg:w-1/3 xl:w-1/4 p-4 dream-column">
    <article
      class="card bg-base-100 hover:bg-base-content/10 shadow-xl dark:border dark:border-base-content/30"
    >
      <div class="card-body">
        <div class="card-title">我的爱好</div>

        <div class="prose dark:prose-invert">
          <ul>
<li>🚀 喜欢折腾各种好玩的技术</li>
<li>📸 业余摄影爱好者</li>
<li>🎮 各类游戏玩家</li>
<li>💻 数码产品折腾爱好者</li>
<li>📚 阅读：赫尔曼·黑塞 &amp; 阿尔贝·加缪</li>
<li>🎞️ 追番中：《电锯人：蕾塞篇》</li>
<li>🎬 经典重温：《命运石之门》</li>
</ul>

        </div>
      </div>
    </article>
  </div>
  
  <div class="w-full md:w-1/2 lg:w-1/3 xl:w-1/4 p-4 dream-column">
    <article
      class="card bg-base-100 hover:bg-base-content/10 shadow-xl dark:border dark:border-base-content/30"
    >
      <div class="card-body">
        <div class="card-title">最近正在学</div>

        <div class="prose dark:prose-invert">
          <ul>
<li>🎨 <a href="https://games104.boomingtech.com/" target="_blank">GAMES104</a>
 —— 现代游戏引擎入门。</li>
<li>🏔️ <a href="https://www.sidefx.com/learn/" target="_blank">Houdini 基础</a>
 —— 学习程序化建模与特效。</li>
<li>🤗 <a href="https://huggingface.co/learn" target="_blank">Hugging Face</a>
 —— 探索开源 AI 社区。</li>
</ul>

        </div>
      </div>
    </article>
  </div>
  
  

  

  
</div>

            

            
<footer class="flex justify-between items-center gap-2 px-4 py-12">

  <div>
  
  <p>
    © 2021 - 2026 古月月仔的博客
  </p>
  

  
  <p class="text-sm">
    🌱
    <span class="text-base-content/60">
      Powered by <a class="hover:underline" href="https://gohugo.io/" target="_blank">Hugo</a> with theme
      <a class="hover:underline" href="https://github.com/g1eny0ung/hugo-theme-dream" target="_blank">Dream</a>.</span
    >
  </p>
  
</div>

  <div
  x-data="{ icons: [
    { name: 'sunny', status: 'n' },
    { name: 'moon', status: 'y' },
    { name: 'desktop', status: 'auto' }
  ] }"
  class="flex items-center gap-2 h-[32px] px-2 bg-base-100 border border-base-content/30 rounded-full"
>
  <template x-for="icon in icons">
    <div
      role="button"
      tabindex="0"
      :aria-label="'Select ' + icon.name + ' mode'"
      class="group inline-flex justify-center items-center p-1 rounded-full cursor-pointer hover:bg-primary"
      :class="$store.darkMode.icon() === icon.name && 'bg-primary'"
      @click="$store.darkMode.toggle(icon.status)"
    >
      <ion-icon
        :name="`${icon.name}-outline`"
        class="group-hover:text-primary-content"
        :class="$store.darkMode.icon() === icon.name && 'text-primary-content'"
      >
      </ion-icon>
    </div>
  </template>
</div>

</footer>

          </div>
        </div>
      </div>
    </div>

    <script>
  window.lightTheme = "emerald"
  window.darkTheme = "forest"
</script>


  <script src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js"></script>

  
  
  <script src="/js/grid.js"></script>




<script src="/js/main.js"></script>
    







<script src="/js/toc.js"></script>




  




    

    
      <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [
        ['\\[', '\\]'],
        ['$$', '$$'],
      ], 
      inlineMath: [
        ['\\(', '\\)'],
        ['$', '$'],
      ], 
    },
  }
</script>

    

    

    

    <script type="module" src="https://cdn.jsdelivr.net/npm/ionicons@7.4.0/dist/ionicons/ionicons.esm.js" integrity="sha256-/IFmi82bIhdYWctu0UddSlJqpnzWm7Vh2C4CM32wF/k=" crossorigin="anonymous"></script>
    <script nomodule src="https://cdn.jsdelivr.net/npm/ionicons@7.4.0/dist/ionicons/ionicons.js" integrity="sha256-mr7eJMX3VC3F7G32mk4oWp1C6a2tlMYxUdptfT7uKI8=" crossorigin="anonymous"></script>
  </body>
</html>
